---
title: .NET에서 I/O 오류 처리
ms.date: 08/27/2018
ms.technology: dotnet-standard
ms.topic: article
helpviewer_keywords:
- I/O, exception handling
- I/O, errors
author: rpetrusha
ms.author: ronpet
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 50dee427913e1ec94a06f1202966bb0f7f5f2099
ms.sourcegitcommit: ad99773e5e45068ce03b99518008397e1299e0d1
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/24/2018
ms.locfileid: "46696419"
---
# <a name="handling-io-errors-in-net"></a><span data-ttu-id="3491a-102">.NET에서 I/O 오류 처리</span><span class="sxs-lookup"><span data-stu-id="3491a-102">Handling I/O errors in .NET</span></span>

<span data-ttu-id="3491a-103">메서드 호출에서 throw될 수 있는 예외(예: 시스템 부하가 큰 경우의 <xref:System.NullReferenceException> 또는 프로그래머 오류로 인한 <xref:System.OutOfMemoryException>) 외에도, .NET 파일 시스템 메서드는 다음과 같은 예외를 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-103">In addition to the exceptions that can be thrown in any method call (such as an <xref:System.OutOfMemoryException> when a system is stressed or an <xref:System.NullReferenceException> due to programmer error), .NET file system methods can throw the following exceptions:</span></span>

- <span data-ttu-id="3491a-104"><xref:System.IO.IOException?displayProperty=nameWithType> - 모든 <xref:System.IO> 예외 유형의 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-104"><xref:System.IO.IOException?displayProperty=nameWithType>, the base class of all <xref:System.IO> exception types.</span></span> <span data-ttu-id="3491a-105">운영 체제의 반환 코드가 다른 예외 유형에 직접 매핑되지 않는 오류에 대해 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-105">It is thrown for errors whose return codes from the operating system don't directly map to any other exception type.</span></span>
- <span data-ttu-id="3491a-106"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-106"><xref:System.IO.FileNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-107"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-107"><xref:System.IO.DirectoryNotFoundException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-108"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-108"><xref:System.IO.DriveNotFoundException??displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-109"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-109"><xref:System.IO.PathTooLongException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-110"><xref:System.OperationCanceledException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-110"><xref:System.OperationCanceledException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-111"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3491a-111"><xref:System.UnauthorizedAccessException?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3491a-112"><xref:System.ArgumentException?displayProperty=nameWithType> - .NET Framework와 .NET Core 2.0 및 이전 버전에서 잘못된 경로 문자에 대해 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-112"><xref:System.ArgumentException?displayProperty=nameWithType>, which is thrown for invalid path characters on .NET Framework and on .NET Core 2.0 and previous versions.</span></span>
- <span data-ttu-id="3491a-113"><xref:System.NotSupportedException?displayProperty=nameWithType> - .NET Framework의 잘못된 콜론에 대해 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-113"><xref:System.NotSupportedException?displayProperty=nameWithType>, which is thrown for invalid colons in .NET Framework.</span></span>
- <span data-ttu-id="3491a-114"><xref:System.Security.SecurityException?displayProperty=nameWithType> - .NET Framework에서만 필요한 권한이 없는, 제한된 신뢰로 실행되는 응용 프로그램에 대해 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-114"><xref:System.Security.SecurityException?displayProperty=nameWithType>, which is thrown for applications running in limited trust that lack the necessary permissions on .NET Framework only.</span></span> <span data-ttu-id="3491a-115">(.NET Framework의 기본값은 완전 신뢰입니다.)</span><span class="sxs-lookup"><span data-stu-id="3491a-115">(Full trust is the default on .NET Framework.)</span></span>

## <a name="mapping-error-codes-to-exceptions"></a><span data-ttu-id="3491a-116">예외에 오류 코드 매핑</span><span class="sxs-lookup"><span data-stu-id="3491a-116">Mapping error codes to exceptions</span></span>

<span data-ttu-id="3491a-117">파일 시스템은 운영 체제 리소스이므로 .NET Core와 .NET Framework의 I/O 메서드는 기본 운영 체제 호출을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-117">Because the file system is an operating system resource, I/O methods in both .NET Core and .NET Framework wrap calls to the underlying operating system.</span></span> <span data-ttu-id="3491a-118">운영 체제가 실행한 코드에서 I/O 오류가 발생할 경우 운영 체제는 .NET I/O 메서드에 오류 정보를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-118">When an I/O error occurs in code executed by the operating system, the operating system returns error information to the .NET I/O method.</span></span> <span data-ttu-id="3491a-119">그런 다음, 메서드가 일반적으로 오류 코드 형태인 오류 정보를 .NET 예외 유형으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-119">The method then translates the error information, typically in the form of an error code, into a .NET exception type.</span></span> <span data-ttu-id="3491a-120">대부분의 경우 이 작업을 위해 오류 코드를 해당 예외 유형으로 직접 변환하며, 메서드 호출 컨텍스트에 따라 오류의 특수 매핑을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-120">In most cases, it does this by directly translating the error code into its corresponding exception type; it does not perform any special mapping of the error based on the context of the method call.</span></span>

<span data-ttu-id="3491a-121">예를 들어 Windows 운영 체제에서 `ERROR_FILE_NOT_FOUND`의 오류 코드(또는 0x02)를 반환하는 메서드 호출은 <xref:System.IO.FileNotFoundException>에 매핑되고, `ERROR_PATH_NOT_FOUND`의 오류 코드(또는 0x03)를 반환하는 메서드 호출은 <xref:System.IO.DirectoryNotFoundException>에 매핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-121">For example, on the Windows operating system, a method call that returns an error code of `ERROR_FILE_NOT_FOUND` (or 0x02) maps to a <xref:System.IO.FileNotFoundException>, and an error code of `ERROR_PATH_NOT_FOUND` (or 0x03) maps to a <xref:System.IO.DirectoryNotFoundException>.</span></span>

<span data-ttu-id="3491a-122">그러나 운영 체제가 특정 오류 코드를 반환하는 정확한 조건은 문서화되지 않거나 잘못 문서화된 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-122">However, the precise conditions under which the operating system returns particular error codes is often undocumented or poorly documented.</span></span> <span data-ttu-id="3491a-123">따라서 예기치 않은 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-123">As a result, unexpected exceptions can occur.</span></span> <span data-ttu-id="3491a-124">예를 들어 파일이 아닌 디렉터리로 작업하고 있기 때문에 <xref:System.IO.DirectoryInfo.%23ctor%2A?displayProperty=nameWithType> 생성자에 잘못된 디렉터리 경로를 제공하면 <xref:System.IO.DirectoryNotFoundException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-124">For example, because you are working with a directory rather than a file, you would expect that providing an invalid directory path to the <xref:System.IO.DirectoryInfo.%23ctor%2A?displayProperty=nameWithType> constructor throws a <xref:System.IO.DirectoryNotFoundException>.</span></span> <span data-ttu-id="3491a-125">그러나 <xref:System.IO.FileNotFoundException>이 throw될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-125">However, it may also throw a <xref:System.IO.FileNotFoundException>.</span></span>

## <a name="exception-handling-in-io-operations"></a><span data-ttu-id="3491a-126">I/O 작업의 예외 처리</span><span class="sxs-lookup"><span data-stu-id="3491a-126">Exception handling in I/O operations</span></span>

<span data-ttu-id="3491a-127">이러한 운영 체제 사용 때문에 예제의 디렉터리를 찾을 수 없음 오류와 같은 동일한 예외 조건에서 I/O 메서드가 I/O 예외의 전체 클래스 중 하나를 임의로 throw할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-127">Because of this reliance on the operating system, identical exception conditions (such as the directory not found error in our example) can result in an I/O method throwing any one of the entire class of I/O exceptions.</span></span> <span data-ttu-id="3491a-128">따라서 I/O API를 호출할 때 다음 표와 같이 이러한 예외를 대부분 또는 모두 처리할 수 있도록 코드를 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-128">This means that, when calling I/O APIs, your code should be prepared to handle most or all of these exceptions, as shown in the following table:</span></span>

| <span data-ttu-id="3491a-129">예외 형식</span><span class="sxs-lookup"><span data-stu-id="3491a-129">Exception type</span></span> | <span data-ttu-id="3491a-130">.NET Core</span><span class="sxs-lookup"><span data-stu-id="3491a-130">.NET Core</span></span> | <span data-ttu-id="3491a-131">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="3491a-131">.NET Framework</span></span> |
|---|---|---|
| <xref:System.IO.IOException> | <span data-ttu-id="3491a-132">예</span><span class="sxs-lookup"><span data-stu-id="3491a-132">Yes</span></span> | <span data-ttu-id="3491a-133">예</span><span class="sxs-lookup"><span data-stu-id="3491a-133">Yes</span></span> |
| <xref:System.IO.FileNotFoundException> | <span data-ttu-id="3491a-134">예</span><span class="sxs-lookup"><span data-stu-id="3491a-134">Yes</span></span> | <span data-ttu-id="3491a-135">예</span><span class="sxs-lookup"><span data-stu-id="3491a-135">Yes</span></span> |
| <xref:System.IO.DirectoryNotFoundException> | <span data-ttu-id="3491a-136">예</span><span class="sxs-lookup"><span data-stu-id="3491a-136">Yes</span></span> | <span data-ttu-id="3491a-137">예</span><span class="sxs-lookup"><span data-stu-id="3491a-137">Yes</span></span> |
| <xref:System.IO.DriveNotFoundException?> | <span data-ttu-id="3491a-138">예</span><span class="sxs-lookup"><span data-stu-id="3491a-138">Yes</span></span> | <span data-ttu-id="3491a-139">예</span><span class="sxs-lookup"><span data-stu-id="3491a-139">Yes</span></span> |
| <xref:System.IO.PathTooLongException> | <span data-ttu-id="3491a-140">예</span><span class="sxs-lookup"><span data-stu-id="3491a-140">Yes</span></span> | <span data-ttu-id="3491a-141">예</span><span class="sxs-lookup"><span data-stu-id="3491a-141">Yes</span></span> |
| <xref:System.OperationCanceledException> | <span data-ttu-id="3491a-142">예</span><span class="sxs-lookup"><span data-stu-id="3491a-142">Yes</span></span> | <span data-ttu-id="3491a-143">예</span><span class="sxs-lookup"><span data-stu-id="3491a-143">Yes</span></span> |
| <xref:System.UnauthorizedAccessException> | <span data-ttu-id="3491a-144">예</span><span class="sxs-lookup"><span data-stu-id="3491a-144">Yes</span></span> | <span data-ttu-id="3491a-145">예</span><span class="sxs-lookup"><span data-stu-id="3491a-145">Yes</span></span> |
| <xref:System.ArgumentException> | <span data-ttu-id="3491a-146">.NET Core 2.0 및 이전</span><span class="sxs-lookup"><span data-stu-id="3491a-146">.NET Core 2.0 and earlier</span></span>| <span data-ttu-id="3491a-147">예</span><span class="sxs-lookup"><span data-stu-id="3491a-147">Yes</span></span> |
| <xref:System.NotSupportedException> | <span data-ttu-id="3491a-148">아니요</span><span class="sxs-lookup"><span data-stu-id="3491a-148">No</span></span> | <span data-ttu-id="3491a-149">예</span><span class="sxs-lookup"><span data-stu-id="3491a-149">Yes</span></span> |
| <xref:System.Security.SecurityException> | <span data-ttu-id="3491a-150">아니요</span><span class="sxs-lookup"><span data-stu-id="3491a-150">No</span></span> | <span data-ttu-id="3491a-151">제한된 신뢰만</span><span class="sxs-lookup"><span data-stu-id="3491a-151">Limited trust only</span></span> |

## <a name="handling-ioexception"></a><span data-ttu-id="3491a-152">IOException 처리</span><span class="sxs-lookup"><span data-stu-id="3491a-152">Handling IOException</span></span>

<span data-ttu-id="3491a-153"><xref:System.IO> 네임스페이스에 있는 예외의 기본 클래스인 <xref:System.IO.IOException>은 미리 정의된 예외 유형에 매핑되지 않는 오류 코드에 대해서도 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-153">As the base class for exceptions in the <xref:System.IO> namespace, <xref:System.IO.IOException> is also thrown for any error code that does not map to a predefined exception type.</span></span> <span data-ttu-id="3491a-154">따라서 이 예외는 모든 I/O 작업에서 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-154">This means that it can be thrown by any I/O operation.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="3491a-155"><xref:System.IO.IOException>은 <xref:System.IO> 네임스페이스에 있는 다른 예외 유형의 기본 클래스이므로 다른 I/O 관련 예외를 처리한 후에 `catch` 블록에서 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-155">Because <xref:System.IO.IOException> is the base class of the other exception types in the <xref:System.IO> namespace, you should handle in a `catch` block after you've handled the other I/O-related exceptions.</span></span>

<span data-ttu-id="3491a-156">또한 .NET Core 2.1부터 경로 정확성에 대한 유효성 검사(예: 경로에 잘못된 문자가 없는지 확인)가 제거되었으며, 런타임 시 자체 유효성 검사 코드가 아닌 운영 체제 오류 코드에서 매핑된 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-156">In addition, starting with .NET Core 2.1, validation checks for path correctness (for example, to ensure that invalid characters are not present in a path) have been removed, and the runtime throws an exception mapped from an operating system error code rather than from its own validation code.</span></span> <span data-ttu-id="3491a-157">이 경우에 throw될 가능성이 큰 예외는 <xref:System.IO.IOException>이지만 다른 예외 유형도 throw될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-157">The most likely exception to be thrown in this case is an <xref:System.IO.IOException>, although any other exception type could also be thrown.</span></span>

<span data-ttu-id="3491a-158">예외 처리 코드에서 <xref:System.IO.IOException>을 항상 마지막에 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-158">Note that, in your exception handling code, you should always handle the <xref:System.IO.IOException> last.</span></span> <span data-ttu-id="3491a-159">그러지 않으면 다른 모든 IO 예외의 기본 클래스이므로 파생 클래스의 catch 블록이 평가되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-159">Otherwise, because it is the base class of all other IO exceptions, the catch blocks of derived classes will not be evaluated.</span></span>

<span data-ttu-id="3491a-160"><xref:System.IO.IOException>의 경우 [IOException.HResult](xref:System.Exception.HResult) 속성에서 추가 오류 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-160">In the case of an <xref:System.IO.IOException>, you can get additional error information from the [IOException.HResult](xref:System.Exception.HResult) property.</span></span> <span data-ttu-id="3491a-161">HResult 값을 Win32 오류 코드로 변환하려면 32비트 값의 상위 16비트를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-161">To convert the HResult value to a Win32 error code, you strip out the upper 16 bits of the 32-bit value.</span></span> <span data-ttu-id="3491a-162">다음 표에는 <xref:System.IO.IOException>에 래핑될 수 있는 오류 코드가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-162">The following table lists error codes that may be wrapped in an <xref:System.IO.IOException>.</span></span>

| <span data-ttu-id="3491a-163">HResult</span><span class="sxs-lookup"><span data-stu-id="3491a-163">HResult</span></span> | <span data-ttu-id="3491a-164">상수</span><span class="sxs-lookup"><span data-stu-id="3491a-164">Constant</span></span> | <span data-ttu-id="3491a-165">설명</span><span class="sxs-lookup"><span data-stu-id="3491a-165">Description</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3491a-166">ERROR_SHARING_VIOLATION</span><span class="sxs-lookup"><span data-stu-id="3491a-166">ERROR_SHARING_VIOLATION</span></span> | <span data-ttu-id="3491a-167">32</span><span class="sxs-lookup"><span data-stu-id="3491a-167">32</span></span> | <span data-ttu-id="3491a-168">파일 이름이 없거나 파일 또는 디렉터리가 사용 중입니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-168">The file name is missing, or the file or directory is in use.</span></span> |
| <span data-ttu-id="3491a-169">ERROR_FILE_EXISTS</span><span class="sxs-lookup"><span data-stu-id="3491a-169">ERROR_FILE_EXISTS</span></span> | <span data-ttu-id="3491a-170">80</span><span class="sxs-lookup"><span data-stu-id="3491a-170">80</span></span> | <span data-ttu-id="3491a-171">파일이 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-171">The file already exists.</span></span> |
| <span data-ttu-id="3491a-172">ERROR_INVALID_PARAMETER</span><span class="sxs-lookup"><span data-stu-id="3491a-172">ERROR_INVALID_PARAMETER</span></span> | <span data-ttu-id="3491a-173">87</span><span class="sxs-lookup"><span data-stu-id="3491a-173">87</span></span> | <span data-ttu-id="3491a-174">메서드에 제공된 인수가 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-174">An argument supplied to the method is invalid.</span></span> |
| <span data-ttu-id="3491a-175">ERROR_ALREADY_EXISTS</span><span class="sxs-lookup"><span data-stu-id="3491a-175">ERROR_ALREADY_EXISTS</span></span> | <span data-ttu-id="3491a-176">183</span><span class="sxs-lookup"><span data-stu-id="3491a-176">183</span></span> | <span data-ttu-id="3491a-177">파일 또는 디렉터리가 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-177">The file or directory already exists.</span></span> |

<span data-ttu-id="3491a-178">다음 예제와 같이 catch 문에서 `When` 절을 사용하여 이러한 예외를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3491a-178">You can handle these using a `When` clause in a catch statement, as the following example shows.</span></span>

[!code-csharp[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/cs/io-exceptions.cs)]
[!code-vb[io-exception-handling](~/samples/snippets/standard/io/io-exceptions/vb/io-exceptions.vb)]

## <a name="see-also"></a><span data-ttu-id="3491a-179">참고 항목</span><span class="sxs-lookup"><span data-stu-id="3491a-179">See also</span></span>

- [<span data-ttu-id="3491a-180">.NET의 예외 처리 및 Throw</span><span class="sxs-lookup"><span data-stu-id="3491a-180">Handling and throwing exceptions in .NET</span></span>](../exceptions/index.md)
- [<span data-ttu-id="3491a-181">예외 처리(작업 병렬 라이브러리)</span><span class="sxs-lookup"><span data-stu-id="3491a-181">Exception handling (Task Parallel Library)</span></span>](../parallel-programming/exception-handling-task-parallel-library.md)
- [<span data-ttu-id="3491a-182">예외에 대한 모범 사례</span><span class="sxs-lookup"><span data-stu-id="3491a-182">Best practices for exceptions</span></span>](../exceptions/best-practices-for-exceptions.md)
- [<span data-ttu-id="3491a-183">catch 블록에서 특정 예외를 사용하는 방법</span><span class="sxs-lookup"><span data-stu-id="3491a-183">How to use specific exceptions in a catch block</span></span>](../exceptions/how-to-use-specific-exceptions-in-a-catch-block.md)