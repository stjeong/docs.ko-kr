---
title: DevOps 공동 작업을 위한 기초로 컨테이너
description: DevOps를 간소화 하는 컨테이너의 키 역할을 이해 합니다.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 02/15/2019
ms.openlocfilehash: 752a678be7735f7ae962005e1d373993d1496753
ms.sourcegitcommit: 07c4368273b446555cb2c85397ea266b39d5fe50
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/21/2019
ms.locfileid: "56583734"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="8b8a7-103">DevOps 공동 작업을 위한 기초로 컨테이너</span><span class="sxs-lookup"><span data-stu-id="8b8a7-103">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="8b8a7-104">컨테이너 및 Docker 기술을 매우 기본적으로 개발자와 공유할 수는 소프트웨어 및 종속성 쉽게 IT 운영 및 프로덕션 환경 일반적인 "작동 내 컴퓨터에서" 변명을 제거 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-104">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="8b8a7-105">컨테이너는 서로 다른 환경 간에 응용 프로그램 충돌을 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-105">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="8b8a7-106">직접 컨테이너 및 Docker 하지 개발자와 IT 운영에 더 가깝게를 모을 쉽게 효율적으로 공동 작업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-106">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="8b8a7-107">컨테이너 워크플로 채택 하 고 많은 고객이 검색 했으므로 있지만 이전 릴리스에 대 한 더 복잡 한 구성을 통해 구현 하 고 파이프라인을 구축 해야 했습니다 DevOps 연속성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-107">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="8b8a7-108">컨테이너는 DevOps의 빌드/테스트/배포 파이프라인을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-108">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![Docker 개발 및 설계 워크 로드 및 실행/모니터링/관리 작업에서 IT 운영에 개발자 및 설계자 간의 브리지를 빌드하는 데 도움이 됩니다.](./media/image1.png)

<span data-ttu-id="8b8a7-110">**그림 2-1.**</span><span class="sxs-lookup"><span data-stu-id="8b8a7-110">**Figure 2-1.**</span></span> <span data-ttu-id="8b8a7-111">컨테이너 화 된 Docker 응용 프로그램에 대 한 수명 주기에서 "가상"사용자 당 기본 워크 로드</span><span class="sxs-lookup"><span data-stu-id="8b8a7-111">Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="8b8a7-112">Docker 컨테이너를 개발자 고유의 (응용 프로그램 및 서비스에 프레임 워크 및 구성 요소에 대 한 종속성)는 컨테이너와 컨테이너 및 서비스를 함께 서비스의 컬렉션으로 구성 된 응용 프로그램으로 동작 내에서 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-112">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="8b8a7-113">에 정의 된 여러 컨테이너의 상호 종속성을 `docker-compose.yml` 파일 또는 호출 될 수는 *배포 매니페스트*합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-113">The interdependencies of the multiple containers are defined in a `docker-compose.yml` file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="8b8a7-114">IT 운영 팀 (IT 전문가 및 관리) 프로덕션 환경의; 관리에 집중할 수는 한편, 인프라 확장성입니다. 모니터링, 고 궁극적으로 응용 프로그램 제공 하는 제대로 최종 사용자에 대 한 다양 한 컨테이너의 내용을 알 필요 없이 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-114">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="8b8a7-115">따라서 이름 "컨테이너" 실제 배송 컨테이너에 비유를 회수 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-115">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="8b8a7-116">따라서 컨테이너의 콘텐츠 소유자 필요 하지 관련이 어떻게 컨테이너 제공 될를 사용 하 여 자체 및 배송 회사 전송 대상 원본 지점에서 컨테이너를 파악 하거나 콘텐츠에 대 한 고려 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-116">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="8b8a7-117">유사한 방식으로 개발자가 만들고 "전송" 메커니즘을 염려 하지 않아도 Docker 컨테이너 내에서 콘텐츠를 소유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-117">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="8b8a7-118">그림 2-1의 좌 변에 있는 pillar, 개발자가 작성 한 Docker에 대 한 Windows 또는 Mac. 사용 하 여 로컬로 Docker 컨테이너에서 코드 실행</span><span class="sxs-lookup"><span data-stu-id="8b8a7-118">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="8b8a7-119">Docker 이미지에 해당 코드를 빌드하는 빌드 단계 및 실행 하려면 기본 운영 체제를 지정 하는 Dockerfile을 사용 하 여 코드에 대 한 운영 환경을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-119">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="8b8a7-120">어떻게 하나 이상의 이미지를 정의 하는 개발자는 앞서 언급 한를 사용 하 여 상호 운용 `docker-compose.yml` 배포 매니페스트 파일.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-120">The developers define how one or more images will interoperate using the aforementioned `docker-compose.yml` file deployment manifest.</span></span> <span data-ttu-id="8b8a7-121">로컬 개발을 완료 될 때마다 이러한 응용 프로그램 코드와 Docker 구성 파일이 코드 리포지토리에 푸시합니다 (즉, Git 리포지토리) 선택한 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-121">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="8b8a7-122">DevOps 기본 제공 코드 리포지토리에 Dockerfile을 사용 하 여 빌드 – 연속 통합 (CI) 파이프라인을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-122">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="8b8a7-123">CI 시스템 선택한 Docker 레지스트리에서 기본 컨테이너 이미지를 가져옵니다 하 고 응용 프로그램에 대 한 사용자 지정 Docker 이미지를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-123">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="8b8a7-124">이미지 다음 유효성이 검사 되며 여러 환경에 배포에 사용 되는 Docker 레지스트리로 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-124">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="8b8a7-125">응용 프로그램 및 사용자 의견 및 응용 프로그램 수 하는 방법에 대 한 개발 팀에 대 한 정보를 제공할 수 있습니다 이러한 환경 및 응용 프로그램을 모니터링 하는 동안 프로덕션 환경에서 인프라에 오른쪽 pillar, 팀 관리 작업을 배포 향상 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-125">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="8b8a7-126">컨테이너 앱은 일반적으로 컨테이너 오 케 스트레이 터를 사용 하 여 프로덕션에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-126">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="8b8a7-127">두 팀을 분리를 계약으로 응용 프로그램 수명 주기에서 두 팀의 공동 작업을 크게 개선 하는 동안 제공 하는 기본 플랫폼 (Docker 컨테이너)를 통해 공동 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-127">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="8b8a7-128">개발자가 컨테이너 내용을, 운영 환경 및 컨테이너 상호 종속성을 소유할 반면 운영 팀을 매니페스트 함께 빌드된 이미지를 가져오고 해당 오케스트레이션 시스템에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-128">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="challenges-in-application-life-cycle-when-using-docker"></a><span data-ttu-id="8b8a7-129">Docker를 사용 하는 경우를 순환 하는 응용 프로그램 수명에서 문제를 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-129">Challenges in application life cycle when using Docker.</span></span>

<span data-ttu-id="8b8a7-130">향후 몇 년 동안에서 컨테이너 화 된 응용 프로그램의 수가 증가 하는 많은 이유가 있습니다 하 고 다음과 같은이 이유 중 하나는 마이크로 서비스 기반 응용 프로그램을 만들 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-130">There are many reasons that will increase the number of containerized applications in the upcoming years, and one of these reasons is the creation of applications based on microservices.</span></span>

<span data-ttu-id="8b8a7-131">지난 15 년 동안 웹 서비스를 사용 하 여 수천 개의 응용 프로그램의 기본 되었고, 아마도 몇 년이 지나면 살펴보면 같은 상황 Docker 컨테이너에서 실행 되는 마이크로 서비스 기반 응용 프로그램과.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-131">During the last 15 years, the use of web services has been the base of thousands of applications, and probably, after a few years, we will find the same situation with microservice-based applications running on Docker containers.</span></span>

<span data-ttu-id="8b8a7-132">역시 모놀리식 응용 프로그램에 대 한 Docker 컨테이너를 사용할 수도 있습니다를 여전히 발생 하면 Docker의 이점 대부분 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-132">It is also worth to mention that you can also use Docker containers for monolithic applications and you still get most of the benefits of Docker.</span></span> <span data-ttu-id="8b8a7-133">컨테이너는 마이크로 서비스만 대상으로 하지 않는 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-133">Containers are not targeting only microservices.</span></span>

<span data-ttu-id="8b8a7-134">많은 컨테이너 및 마이크로 서비스를 프로덕션 시스템에서 실행을 유지 하려면 견고한 전략을 해야 하는 문제의 Docker 컨테이너 화 및 마이크로 서비스 원인 새 조직 및 따라서의 개발 프로세스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-134">The use of Docker containerization and microservices causes new challenges in the development process of your organizations and therefore, you need a solid strategy to maintain many containers and microservices running on production systems.</span></span> <span data-ttu-id="8b8a7-135">결과적으로, 엔터프라이즈 응용 프로그램을 수백 또는 수천 개의 컨테이너/인스턴스가 프로덕션 환경에서 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-135">Eventually, enterprise applications will have hundreds or thousands of containers/instances running in production.</span></span>

<span data-ttu-id="8b8a7-136">이러한 문제는 DevOps 활동에서 새 프로세스를 정의 하 여 이러한 유형의 질문에 대 한 답변을 찾을 것 DevOps 도구를 사용 하는 경우 조직의 새로운 요구 사항을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-136">These challenges create new demands when using DevOps tools, so you'll have to define new processes in your DevOps activities, and find answers for this type of questions:</span></span>

- <span data-ttu-id="8b8a7-137">CI/CD, 관리 및 작업에 대 한 개발을 위해 사용할 수 있는 도구</span><span class="sxs-lookup"><span data-stu-id="8b8a7-137">Which tools can I use for development, for CI/CD, management and operations?</span></span>

- <span data-ttu-id="8b8a7-138">어떻게 회사 관리할 수 오류 컨테이너에서 프로덕션 환경에서 실행 하는 경우?</span><span class="sxs-lookup"><span data-stu-id="8b8a7-138">How can my company manage errors in containers when running in production?</span></span>

- <span data-ttu-id="8b8a7-139">최소 가동 중지 시간을 사용 하 여 프로덕션 환경에서 소프트웨어는 어떻게 변경 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="8b8a7-139">How can we change pieces of our software in production with minimum downtime?</span></span>

- <span data-ttu-id="8b8a7-140">에서는 확장 하 고 프로덕션 시스템 어떻게 모니터링할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="8b8a7-140">How can we scale and how can we monitor our production system?</span></span>

- <span data-ttu-id="8b8a7-141">테스트 및 컨테이너의 배포 릴리스 파이프라인에 포함할 수 있습니다 어떻게 해야 했습니다?</span><span class="sxs-lookup"><span data-stu-id="8b8a7-141">How can we include testing and deployment of containers in our release pipeline?</span></span>

- <span data-ttu-id="8b8a7-142">Microsoft Azure에서 컨테이너에 대 한 오픈 소스 도구/플랫폼 어떻게 사용할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="8b8a7-142">How can we use Open Source tools/platforms for containers in Microsoft Azure?</span></span>

<span data-ttu-id="8b8a7-143">이러한 모든 질문에 대답할 수 있습니다, 경우 해야 더 잘 (기존 또는 새 앱)을 Docker 컨테이너로 응용 프로그램을 이동할 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-143">If you can answer all those questions, you will be better prepared to move your applications (existing or new apps) to Docker containers.</span></span> 

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="8b8a7-144">제네릭 엔드-투-엔드 Docker 응용 프로그램 수명 주기 워크플로 소개</span><span class="sxs-lookup"><span data-stu-id="8b8a7-144">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="8b8a7-145">그림 2-2은 특정 DevOps 작업 및 자산에이 인스턴스에서 집중 Docker 응용 프로그램 수명 주기를 위한 자세한 워크플로.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-145">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![이 다이어그램에서는 DevOps의 "외부 루프"를 보여 줍니다.](./media/image2.png)

<span data-ttu-id="8b8a7-149">**그림 2-2입니다.**</span><span class="sxs-lookup"><span data-stu-id="8b8a7-149">**Figure 2-2.**</span></span> <span data-ttu-id="8b8a7-150">Docker 컨테이너 화 된 응용 프로그램 수명 주기에 대 한 개략적인 워크플로</span><span class="sxs-lookup"><span data-stu-id="8b8a7-150">High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="8b8a7-151">모든 내부 루프 워크플로의 코드 작성을 시작 하는 개발자가 사용 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-151">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="8b8a7-152">내부 루프 단계 코드 (예를 들어, 소스 제어 시스템을 Git과 같은) 코드 리포지토리로 푸시하기 전에 발생 하는 모든 개발자가 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-152">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="8b8a7-153">커밋된 후 리포지토리에 CI (지속적인 통합) 및 워크플로의 나머지 부분을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-153">After it is committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="8b8a7-154">기본적으로 내부 루프 "코드," 실행"," "test" 및 "debug"와 앱을 로컬로 실행 직전 필요한 추가 단계와 같은 일반적인 단계로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-154">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus the additional steps needed right before running the app locally.</span></span> <span data-ttu-id="8b8a7-155">실행 하 고 앱을 Docker 컨테이너로 테스트 개발자의 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-155">This is the developer's process to run and test the app as a Docker container.</span></span> <span data-ttu-id="8b8a7-156">내부 루프 워크플로 다음 섹션에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-156">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="8b8a7-157">단계를 다시 간 최종 워크플로 런타임에 검색할, DevOps 워크플로 수행 하는 기술 또는 도구 집합 보다: 문화적 발전 해야 하는 하나의 사고방식입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-157">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="8b8a7-158">인력, 프로세스 및 적절 한 도구 빠르고 예측 가능성이 더욱 뛰어난 응용 프로그램 수명 주기를 확인 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-158">It is people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="8b8a7-159">기업은 일반적으로 컨테이너 화 된 워크플로 채택 하는 사람 및 컨테이너 화 된 워크플로 일치 하는 프로세스를 나타내는 조직 재구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-159">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="8b8a7-160">DevOps를 캡처하므로 더 빠르게 응답 함께 경쟁 정리가 향상 된 추적 가능성 및 반복 가능한 워크플로 자동화를 사용 하 여 오류가 발생 하기 쉬운 수동 프로세스를 대체 하 여 팀 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-160">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="8b8a7-161">조직은 환경을 보다 효율적으로 관리 하 고 수도 긴밀 하 게 통합 된 도구와 온-프레미스 및 클라우드 리소스를 조합 하 여 비용 절감을 실현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-161">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="8b8a7-162">Docker 응용 프로그램에 대 한 DevOps 워크플로 구현할 때 Docker 기술은 빌드-테스트-CI 단계는 (코드, 실행, 디버그), 내부 루프에서 작업 하는 동안 개발 상자에 있는 워크플로의 거의 모든 단계에서 볼 수 있습니다 하 고, 마지막으로, 스테이징 및 프로덕션 환경에 해당 컨테이너의 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-162">When implementing your DevOps workflow for Docker applications, you'll see that Docker technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), the build-test-CI phase, and, finally, the deployment of those containers to the staging and production environments.</span></span>

<span data-ttu-id="8b8a7-163">품질 사례 향상 수정 비용을 줄일 수 있는 개발 주기의 초기에 결함을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-163">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="8b8a7-164">환경 및 종속성을 포함 하 여 이미지에서 및 다양 한 환경에서 동일한 이미지를 배포 하는 원칙을 채택 하 고, 안정적으로 배포할 수 있어 환경별 구성을 추출 하는 분야를 승격할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-164">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="8b8a7-165">효과적인 계측 (모니터링 및 진단)을 통해 가져온 데이터를 다양 한 성능 문제와 향후 우선 순위 및 투자를 안내할 사용자 동작에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-165">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="8b8a7-166">DevOps는 목적지 경험을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-166">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="8b8a7-167">적절 하 게 범위가 지정 된 프로젝트는 성공을 보여, 자세한를 발전을 통해 증분 방식으로 구현 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-167">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="8b8a7-168">컨테이너 화 된 응용 프로그램에 대 한 DevOps의 이점</span><span class="sxs-lookup"><span data-stu-id="8b8a7-168">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="8b8a7-169">다음은 일부 solid DevOps 워크플로에 의해 제공 되는 가장 중요 한 혜택입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-169">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

- <span data-ttu-id="8b8a7-170">빠르고 효율적인 준수를 사용 하 여 더 나은 품질의 소프트웨어를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-170">Deliver better-quality software, faster and with better compliance.</span></span>

- <span data-ttu-id="8b8a7-171">조기에 더 경제적으로 지속적인 향상과 조정 드라이브입니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-171">Drive continuous improvement and adjustments earlier and more economically.</span></span>

- <span data-ttu-id="8b8a7-172">투명도 및 제공 하 고 소프트웨어를 운영 하는 데 참여할된 관련자 간의 공동 작업을 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-172">Increase transparency and collaboration among stakeholders involved in delivering and operating software.</span></span>

- <span data-ttu-id="8b8a7-173">비용을 제어 하 고 보안 위험을 최소화 하면서 보다 효과적으로 프로 비전 된 리소스를 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-173">Control costs and utilize provisioned resources more effectively while minimizing security risks.</span></span>

- <span data-ttu-id="8b8a7-174">다양 한 오픈 소스에 대 한 투자를 포함 하 여 기존 DevOps 투자 잘 플러그 앤 플레이 합니다.</span><span class="sxs-lookup"><span data-stu-id="8b8a7-174">Plug and play well with many of your existing DevOps investments, including investments in open-source.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8b8a7-175">[이전](index.md)
>[다음](../Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="8b8a7-175">[Previous](index.md)
[Next](../Microsoft-platform-tools-containerized-apps/index.md)</span></span>
