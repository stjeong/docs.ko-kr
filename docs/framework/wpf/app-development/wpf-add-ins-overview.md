---
title: WPF 추가 기능 개요
ms.date: 03/30/2017
helpviewer_keywords:
- add-ins and XAML browser applications [WPF]
- add-ins overview [WPF]
- add-ins [WPF], performance
- add-ins [WPF], benefits
- .NET Framework add-in model [WPF]
- add-ins [WPF], user interface
- add-ins and the user interface [WPF]
- add-ins [WPF], architecture
- add-ins [WPF], limitations
ms.assetid: 00b4c776-29a8-4dba-b603-280a0cdc2ade
ms.openlocfilehash: 47e76a1d08f8c85eafa7758ec9fdd80d8ae8afcf
ms.sourcegitcommit: 8f95d3a37e591963ebbb9af6e90686fd5f3b8707
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/23/2019
ms.locfileid: "56746564"
---
# <a name="wpf-add-ins-overview"></a><span data-ttu-id="2c298-102">WPF 추가 기능 개요</span><span class="sxs-lookup"><span data-stu-id="2c298-102">WPF Add-Ins Overview</span></span>
<a name="Introduction"></a> <span data-ttu-id="2c298-103">.NET Framework 개발자가 추가 기능 확장성을 지 원하는 응용 프로그램을 만드는 데 사용할 추가 모델을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-103">The .NET Framework includes an add-in model that developers can use to create applications that support add-in extensibility.</span></span> <span data-ttu-id="2c298-104">이 추가 기능 모델을 사용하면 애플리케이션 기능과 통합하고 이 기능을 확장하는 추가 기능을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-104">This add-in model allows the creation of add-ins that integrate with and extend application functionality.</span></span> <span data-ttu-id="2c298-105">일부 시나리오에서는 응용 프로그램 에서도 추가 기능을 통해 제공 되는 사용자 인터페이스를 표시 해야 합니다. 이 항목에서는 WPF 이러한 시나리오, 해당 이점 및 제한 사항 기반이 되는 아키텍처를 사용 하도록 설정 하려면.NET Framework 추가 기능에서 모델을 보강 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-105">In some scenarios, applications also need to display user interfaces that are provided by add-ins. This topic shows how WPF augments the .NET Framework add-in model to enable these scenarios, the architecture behind it, its benefits, and its limitations.</span></span>  
  

  
<a name="Requirements"></a>   
## <a name="prerequisites"></a><span data-ttu-id="2c298-106">전제 조건</span><span class="sxs-lookup"><span data-stu-id="2c298-106">Prerequisites</span></span>  
 <span data-ttu-id="2c298-107">.NET Framework 추가 기능 모델을 사용 하 여 친근 함이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-107">Familiarity with the .NET Framework add-in model is required.</span></span> <span data-ttu-id="2c298-108">자세한 내용은 [추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2c298-108">For more information, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="AddInsOverview"></a>   
## <a name="add-ins-overview"></a><span data-ttu-id="2c298-109">추가 기능 개요</span><span class="sxs-lookup"><span data-stu-id="2c298-109">Add-Ins Overview</span></span>  
 <span data-ttu-id="2c298-110">애플리케이션에서는 새 기능을 통합하기 위해 애플리케이션을 다시 컴파일하여 배포하는 복잡한 작업을 방지하도록 확장성 메커니즘을 구현하여 개발자(자사 및 타사)가 새 기능을 통합하는 다른 애플리케이션을 만들 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-110">In order to avoid the complexities of application recompilation and redeployment to incorporate new functionality, applications implement extensibility mechanisms that allow developers (both first-party and third-party) to create other applications that integrate with them.</span></span> <span data-ttu-id="2c298-111">이러한 형식의 확장성을 지원하는 가장 일반적인 방법은 추가 기능(“추가 기능” 및 “플러그 인”이라고도 함)을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-111">The most common way to support this type of extensibility is through the use of add-ins (also known as "add-ons" and "plug-ins").</span></span> <span data-ttu-id="2c298-112">추가 기능으로 확장성을 노출하는 실제 애플리케이션의 예에는 다음이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-112">Examples of real-world applications that expose extensibility with add-ins include:</span></span>  
  
-   <span data-ttu-id="2c298-113">Internet Explorer 추가 기능.</span><span class="sxs-lookup"><span data-stu-id="2c298-113">Internet Explorer add-ons.</span></span>  
  
-   <span data-ttu-id="2c298-114">Windows Media Player 플러그 인.</span><span class="sxs-lookup"><span data-stu-id="2c298-114">Windows Media Player plug-ins.</span></span>  
  
-   <span data-ttu-id="2c298-115">Visual Studio 추가 기능.</span><span class="sxs-lookup"><span data-stu-id="2c298-115">Visual Studio add-ins.</span></span>  
  
 <span data-ttu-id="2c298-116">예를 들어, Windows Media Player 추가 기능 모델을 사용하면 타사 개발자가 다양한 방식으로 Windows Media Player를 확장하는 “플러그 인”을 구현할 수 있습니다. 이러한 방식에는 Windows Media Player에서 기본적으로 지원하지 않는 미디어 형식(예: DVD, MP3)의 디코더와 인코더, 오디오 효과 및 스킨이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-116">For example, the Windows Media Player add-in model allows third-party developers to implement "plug-ins" that extend Windows Media Player in a variety of ways, including creating decoders and encoders for media formats that are not supported natively by Windows Media Player (for example, DVD, MP3), audio effects, and skins.</span></span> <span data-ttu-id="2c298-117">모든 추가 기능 모델에 공통인 동작과 엔터티가 여러 개 있지만, 각 추가 기능 모델은 애플리케이션에 고유한 기능을 노출하도록 빌드되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-117">Each add-in model is built to expose the functionality that is unique to an application, although there are several entities and behaviors that are common to all add-in models.</span></span>  
  
 <span data-ttu-id="2c298-118">일반적인 추가 기능 확장성 솔루션의 세 가지 기본 엔터티는 *계약*, *추가 기능* 및 *호스트 애플리케이션*입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-118">The three main entities of typical add-in extensibility solutions are *contracts*, *add-ins*, and *host applications*.</span></span> <span data-ttu-id="2c298-119">계약은 추가 기능이 다음 두 방법으로 호스트 애플리케이션과 통합하는 방법을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-119">Contracts define how add-ins integrate with host applications in two ways:</span></span>  
  
-   <span data-ttu-id="2c298-120">추가 기능은 호스트 애플리케이션으로 구현된 기능과 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-120">Add-ins integrate with functionality that is implemented by host applications.</span></span>  
  
-   <span data-ttu-id="2c298-121">호스트 애플리케이션에서 추가 기능과 통합될 기능을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-121">Host applications expose functionality for add-ins to integrate with.</span></span>  
  
 <span data-ttu-id="2c298-122">추가 기능을 사용하려면 호스트 애플리케이션에서 해당 기능을 찾아 런타임 시 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-122">In order for add-ins to be used, host applications need to find them and load them at run time.</span></span> <span data-ttu-id="2c298-123">따라서 추가 기능을 지원하는 애플리케이션에서는 다음과 같은 추가 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-123">Consequently, applications that support add-ins have the following additional responsibilities:</span></span>  
  
-   <span data-ttu-id="2c298-124">**검색**: 호스트 응용 프로그램에서 지원 되는 계약을 준수 하는 추가 기능 찾기.</span><span class="sxs-lookup"><span data-stu-id="2c298-124">**Discovery**: Finding add-ins that adhere to contracts supported by host applications.</span></span>  
  
-   <span data-ttu-id="2c298-125">**활성화**: 로드 하 고, 실행 및 추가 기능을 사용 하 여 통신을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-125">**Activation**: Loading, running, and establishing communication with add-ins.</span></span>  
  
-   <span data-ttu-id="2c298-126">**격리**: 응용 프로그램 도메인 또는 프로세스를 사용 하 여 잠재적인 보안 및 추가 기능을 사용 하 여 실행 문제 로부터 응용 프로그램을 보호 하는 격리 경계를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-126">**Isolation**: Using either application domains or processes to establish isolation boundaries that protect applications from potential security and execution problems with add-ins.</span></span>  
  
-   <span data-ttu-id="2c298-127">**통신**: 추가 기능을 허용 하 고 호스트 응용 프로그램이 메서드를 호출 하 고 데이터를 전달 하 여 격리 경계를 넘어 서로 통신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-127">**Communication**: Allowing add-ins and host applications to communicate with each other across isolation boundaries by calling methods and passing data.</span></span>  
  
-   <span data-ttu-id="2c298-128">**수명 관리**: 로드 및 응용 프로그램 도메인 및 프로세스를 정리, 예측 가능한 방식으로 언로드 (참조 [응용 프로그램 도메인](../../../../docs/framework/app-domains/application-domains.md)).</span><span class="sxs-lookup"><span data-stu-id="2c298-128">**Lifetime Management**: Loading and unloading application domains and processes in a clean, predictable manner (see [Application Domains](../../../../docs/framework/app-domains/application-domains.md)).</span></span>  
  
-   <span data-ttu-id="2c298-129">**버전 관리**: 호스트 응용 프로그램 및 기능 추가의 새 버전을 만들 때 여전히 통신할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-129">**Versioning**: Ensuring that host applications and add-ins can still communicate when new versions of either are created.</span></span>  
  
 <span data-ttu-id="2c298-130">근본적으로, 강력한 추가 기능 모델을 개발하는 것은 쉬운 작업이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-130">Ultimately, developing a robust add-in model is a non-trivial undertaking.</span></span> <span data-ttu-id="2c298-131">이러한 이유로.NET Framework 추가 기능 모델을 빌드하기 위한 인프라를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-131">For this reason, the .NET Framework provides an infrastructure for building add-in models.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c298-132">추가 기능에 대한 자세한 내용은 [추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2c298-132">For more detailed information on add-ins, see [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
<a name="NETFrameworkAddInModelOverview"></a>   
## <a name="net-framework-add-in-model-overview"></a><span data-ttu-id="2c298-133">.NET Framework 추가 기능 모델 개요</span><span class="sxs-lookup"><span data-stu-id="2c298-133">.NET Framework Add-In Model Overview</span></span>  
 <span data-ttu-id="2c298-134">.NET Framework 추가 기능에서 모델에 있는 <xref:System.AddIn> 네임 스페이스에는 추가 기능 확장성의 개발을 간소화 하도록 설계 된 형식의 집합을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-134">The .NET Framework add-in model, found in the <xref:System.AddIn> namespace, contains a set of types that are designed to simplify the development of add-in extensibility.</span></span> <span data-ttu-id="2c298-135">.NET Framework 추가 기능 모델의 기본 단위를 *계약*, 응용 프로그램을 호스트 하는 방법을 정의 하는 및의 추가 기능 서로 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-135">The fundamental unit of the .NET Framework add-in model is the *contract*, which defines how a host application and an add-in communicate with each other.</span></span> <span data-ttu-id="2c298-136">계약은 계약의 호스트-애플리케이션별 *보기*를 사용하여 호스트 애플리케이션에 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-136">A contract is exposed to a host application using a host-application-specific *view* of the contract.</span></span> <span data-ttu-id="2c298-137">마찬가지로 계약의 추가 기능별 *보기*가 추가 기능에 노출됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-137">Likewise, an add-in-specific *view* of the contract is exposed to the add-in.</span></span> <span data-ttu-id="2c298-138">호스트 애플리케이션과 추가 기능이 계약의 각 보기 간에 통신할 수 있도록 *어댑터*가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-138">An *adapter* is used to allow a host application and an add-in to communicate between their respective views of the contract.</span></span> <span data-ttu-id="2c298-139">계약, 보기 및 어댑터를 세그먼트라고 하며, 관련 세그먼트 집합이 *파이프라인*을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-139">Contracts, views, and adapters are referred to as segments, and a set of related segments constitutes a *pipeline*.</span></span> <span data-ttu-id="2c298-140">파이프라인에는.NET Framework 추가 기능 모델 지원 검색, 활성화, 보안 격리, 실행 격리 (응용 프로그램 도메인 및 프로세스를 모두 사용), 통신, 수명 관리 및 버전 관리 기반이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-140">Pipelines are the foundation upon which the .NET Framework add-in model supports discovery, activation, security isolation, execution isolation (using both application domains and processes), communication, lifetime management, and versioning.</span></span>  
  
 <span data-ttu-id="2c298-141">개발자는 이러한 지원을 모두 활용하여 호스트 애플리케이션의 기능과 통합하는 추가 기능을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-141">The sum of this support allows developers to build add-ins that integrate with the functionality of a host application.</span></span> <span data-ttu-id="2c298-142">그러나 일부 시나리오에는 추가 기능에서 제공 하는 사용자 인터페이스에 표시할 응용 프로그램을 호스트 해야 합니다. .NET Framework의 각 프레젠테이션 기술에 사용자 인터페이스를 구현 하기 위한 자체 모델 때문에.NET Framework 추가 기능 모델에는 어떠한 특정 프레젠테이션 기술을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-142">However, some scenarios require host applications to display user interfaces provided by add-ins. Because each presentation technology in the .NET Framework has its own model for implementing user interfaces, the .NET Framework add-in model does not support any particular presentation technology.</span></span> <span data-ttu-id="2c298-143">대신 WPF는 UI 지 원하는 추가 기능에는.NET Framework 추가 기능 모델을 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-143">Instead, WPF extends the .NET Framework add-in model with UI support for add-ins.</span></span>  
  
<a name="WPFAddInModel"></a>   
## <a name="wpf-add-ins"></a><span data-ttu-id="2c298-144">WPF 추가 기능</span><span class="sxs-lookup"><span data-stu-id="2c298-144">WPF Add-Ins</span></span>  
 <span data-ttu-id="2c298-145">WPF는.NET Framework 추가 기능 모델을와 함께에서 처리할 수 있습니다 다양 한 추가 기능에서 사용자 인터페이스에 표시할 응용 프로그램을 호스트 해야 하는 시나리오입니다. 특히 다음 두 가지 프로그래밍 모델을 사용 하 여 WPF에서 이러한 시나리오를 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-145">WPF, in conjunction with the .NET Framework add-in model, allows you to address a wide variety of scenarios that require host applications to display user interfaces from add-ins. In particular, these scenarios are addressed by WPF with the following two programming models:</span></span>  
  
1.  <span data-ttu-id="2c298-146">**추가 기능이 UI를 반환함**.</span><span class="sxs-lookup"><span data-stu-id="2c298-146">**The add-in returns a UI**.</span></span> <span data-ttu-id="2c298-147">추가 UI를 반환 호스트 응용 프로그램에 메서드 호출을 통해 계약에 정의 된 대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-147">An add-in returns a UI to the host application via a method call, as defined by the contract.</span></span> <span data-ttu-id="2c298-148">이 시나리오는 다음과 같은 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-148">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="2c298-149">존재 하는 조건, 런타임 시에만 같은 동적으로 생성 된 보고서 나 추가 기능에서 반환 되는 UI의 모양을 데이터에 종속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-149">The appearance of a UI that is returned by an add-in is dependent on either data or conditions that exist only at run time, such as dynamically generated reports.</span></span>  
  
    -   <span data-ttu-id="2c298-150">추가 기능에서 제공 하는 서비스에 대 한 UI 추가 기능에서 사용할 수 있는 호스트 응용 프로그램의 UI에서 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-150">The UI for services provided by an add-in differs from the UI of the host applications that can use the add-in.</span></span>  
  
    -   <span data-ttu-id="2c298-151">추가 기능에서 호스트 응용 프로그램에 대 한 서비스를 수행 하 고 UI 사용 하 여 호스트 응용 프로그램 상태를 보고 주로.</span><span class="sxs-lookup"><span data-stu-id="2c298-151">The add-in primarily performs a service for the host application, and reports status to the host application with a UI.</span></span>  
  
2.  <span data-ttu-id="2c298-152">**추가 기능이 UI임**.</span><span class="sxs-lookup"><span data-stu-id="2c298-152">**The add-in is a UI**.</span></span> <span data-ttu-id="2c298-153">추가 기능을 계약으로 정의 된 UI를입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-153">An add-in is a UI, as defined by the contract.</span></span> <span data-ttu-id="2c298-154">이 시나리오는 다음과 같은 경우에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-154">This scenario is used in the following cases:</span></span>  
  
    -   <span data-ttu-id="2c298-155">추가 기능에서 광고와 같이 표시되고 있지 않은 서비스를 제공하지 않는 경우.</span><span class="sxs-lookup"><span data-stu-id="2c298-155">An add-in doesn't provide services other than being displayed, such as an advertisement.</span></span>  
  
    -   <span data-ttu-id="2c298-156">추가 기능에서 제공 하는 서비스에 대 한 UI가 계산기 또는 색 선택기와 같은 추가 기능을 사용할 수 있는 모든 호스트 응용 프로그램에 공통적으로 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-156">The UI for services provided by an add-in is common to all host applications that can use that add-in, such as a calculator or color picker.</span></span>  
  
 <span data-ttu-id="2c298-157">이러한 시나리오에서는 호스트 응용 프로그램과 추가 기능 응용 프로그램 도메인 간에 UI 개체를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-157">These scenarios require that UI objects can be passed between host application and add-in application domains.</span></span> <span data-ttu-id="2c298-158">추가 기능 모델 원격 응용 프로그램 도메인 간에 통신을 통해.NET Framework에서 이후 간에 전달 되는 개체에 원격으로 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-158">Since the .NET Framework add-in model relies on remoting to communicate between application domains, the objects that are passed between them must be remotable.</span></span>  
  
 <span data-ttu-id="2c298-159">원격으로 사용 가능한 개체는 다음 중 하나 이상을 수행하는 클래스의 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-159">A remotable object is an instance of a class that does one or more of the following:</span></span>  
  
-   <span data-ttu-id="2c298-160">파생 되는 <xref:System.MarshalByRefObject> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-160">Derives from the <xref:System.MarshalByRefObject> class.</span></span>  
  
-   <span data-ttu-id="2c298-161"><xref:System.Runtime.Serialization.ISerializable> 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-161">Implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
-   <span data-ttu-id="2c298-162">에 <xref:System.SerializableAttribute> 특성을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-162">Has the <xref:System.SerializableAttribute> attribute applied.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c298-163">원격으로 사용 가능한.NET Framework 개체의 생성과 관련 된 자세한 내용은 [만드는 개체 원격으로 사용 가능한](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-163">For more information regarding the creation of remotable .NET Framework objects, see [Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100)).</span></span>  
  
 <span data-ttu-id="2c298-164">WPF UI 유형을 원격으로 사용 가능한 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-164">The WPF UI types are not remotable.</span></span> <span data-ttu-id="2c298-165">문제를 해결 하려면 WPF 추가 기능을 통해 만든 WPF UI를 호스트 응용 프로그램에서 표시할 수 있도록.NET Framework 추가 기능에서 모델을 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-165">To solve the problem, WPF extends the .NET Framework add-in model to enable WPF UI created by add-ins to be displayed from host applications.</span></span> <span data-ttu-id="2c298-166">이 지원은 두 유형을 통해 WPF에서 제공 됩니다: 합니다 <xref:System.AddIn.Contract.INativeHandleContract> 인터페이스 및 구현한 두 가지 정적 메서드를 <xref:System.AddIn.Pipeline.FrameworkElementAdapters> 클래스: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> 및 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-166">This support is provided by WPF by two types: the <xref:System.AddIn.Contract.INativeHandleContract> interface and two static methods implemented by the <xref:System.AddIn.Pipeline.FrameworkElementAdapters> class: <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span> <span data-ttu-id="2c298-167">상위 수준에서는 대략적으로 이러한 형식과 메서드가 다음과 같은 방식으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-167">At a high level, these types and methods are used in the following manner:</span></span>  
  
1.  <span data-ttu-id="2c298-168">WPF 추가 기능에서 제공 하는 사용자 인터페이스에서 직접 또는 간접적으로 파생 된 클래스에 있어야 <xref:System.Windows.FrameworkElement>도형, 컨트롤, 사용자 컨트롤, 레이아웃 패널 및 페이지 등.</span><span class="sxs-lookup"><span data-stu-id="2c298-168">WPF requires that user interfaces provided by add-ins are classes that derive directly or indirectly from <xref:System.Windows.FrameworkElement>, such as shapes, controls, user controls, layout panels, and pages.</span></span>  
  
2.  <span data-ttu-id="2c298-169">UI를 추가 하 고 호스트 응용 프로그램 간에 전달 되는 선언 하는 계약, 어디서 나로 선언 되어야 합니다는 <xref:System.AddIn.Contract.INativeHandleContract> (하지는 <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> 격리 경계를 넘어 전달 될 수 있는 추가 UI 원격으로 사용 가능한 표현입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-169">Wherever the contract declares that a UI will be passed between the add-in and the host application, it must be declared as an <xref:System.AddIn.Contract.INativeHandleContract> (not a <xref:System.Windows.FrameworkElement>); <xref:System.AddIn.Contract.INativeHandleContract> is a remotable representation of the add-in UI that can be passed across isolation boundaries.</span></span>  
  
3.  <span data-ttu-id="2c298-170">응용 프로그램 도메인에 대 한 추가 기능에서 전달 되기 전에 <xref:System.Windows.FrameworkElement> 으로 패키지를 <xref:System.AddIn.Contract.INativeHandleContract> 를 호출 하 여 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-170">Before being passed from the add-in's application domain, a <xref:System.Windows.FrameworkElement> is packaged as an <xref:System.AddIn.Contract.INativeHandleContract> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
4.  <span data-ttu-id="2c298-171">호스트 응용 프로그램의 응용 프로그램 도메인에 전달 된 후의 <xref:System.AddIn.Contract.INativeHandleContract> 으로 다시 패키지 되어야 합니다는 <xref:System.Windows.FrameworkElement> 를 호출 하 여 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-171">After being passed to the host application's application domain, the <xref:System.AddIn.Contract.INativeHandleContract> must be repackaged as a <xref:System.Windows.FrameworkElement> by calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span>  
  
 <span data-ttu-id="2c298-172">어떻게 <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, 및 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> 되는 특정 시나리오에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-172">How <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> are used depends on the specific scenario.</span></span> <span data-ttu-id="2c298-173">다음 섹션에서는 각 프로그래밍 모델의 자세한 내용을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-173">The following sections provide details for each programming model.</span></span>  
  
<a name="ReturnUIFromAddInContract"></a>   
## <a name="add-in-returns-a-user-interface"></a><span data-ttu-id="2c298-174">추가 기능이 사용자 인터페이스를 반환함</span><span class="sxs-lookup"><span data-stu-id="2c298-174">Add-In Returns a User Interface</span></span>  
 <span data-ttu-id="2c298-175">추가 기능에 대 한 호스트 응용 프로그램 UI를 반환 하려면, 다음 사항이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-175">For an add-in to return a UI to a host application, the following are required:</span></span>  
  
1.  <span data-ttu-id="2c298-176">호스트 응용 프로그램, 추가 기능 및 파이프라인을 만들고,.NET Framework에 설명 된 대로 [추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) 설명서.</span><span class="sxs-lookup"><span data-stu-id="2c298-176">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="2c298-177">계약을 구현 해야 합니다 <xref:System.AddIn.Contract.IContract> UI를 반환 하려면 계약 형식의 반환 값을 사용 하 여 메서드를 선언 해야 하는 고 <xref:System.AddIn.Contract.INativeHandleContract>입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-177">The contract must implement <xref:System.AddIn.Contract.IContract> and, to return a UI, the contract must declare a method with a return value of type <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="2c298-178">추가 기능과 호스트 응용 프로그램 간에 전달 되는 UI를 직접 또는 간접적으로 파생 되어야에서 <xref:System.Windows.FrameworkElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-178">The UI that is passed between the add-in and the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="2c298-179">추가 기능을 통해 반환 되는 UI에서 변환 해야 합니다는 <xref:System.Windows.FrameworkElement> 에 <xref:System.AddIn.Contract.INativeHandleContract> 격리 경계를 통과 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-179">The UI that is returned by the add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="2c298-180">반환 되는 UI에서 변환 해야 합니다는 <xref:System.AddIn.Contract.INativeHandleContract> 에 <xref:System.Windows.FrameworkElement> 격리 경계를 통과 한 후입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-180">The UI that is returned must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="2c298-181">호스트 응용 프로그램은 반환 된 표시 <xref:System.Windows.FrameworkElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-181">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="2c298-182">UI를 반환 하는 추가 기능에서 구현 하는 방법을 보여 주는 예제를 참조 하세요 [UI는 추가 기능에서 반환 하는 만들기](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-182">For an example that demonstrates how to implement an add-in that returns a UI, see [Create an Add-In That Returns a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-returns-a-ui.md).</span></span>  
  
<a name="AddInIsAUI"></a>   
## <a name="add-in-is-a-user-interface"></a><span data-ttu-id="2c298-183">추가 기능이 사용자 인터페이스임</span><span class="sxs-lookup"><span data-stu-id="2c298-183">Add-In Is a User Interface</span></span>  
 <span data-ttu-id="2c298-184">추가 UI가 되 면 다음이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-184">When an add-in is a UI, the following are required:</span></span>  
  
1.  <span data-ttu-id="2c298-185">호스트 응용 프로그램, 추가 기능 및 파이프라인을 만들고,.NET Framework에 설명 된 대로 [추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) 설명서.</span><span class="sxs-lookup"><span data-stu-id="2c298-185">The host application, add-in, and pipeline must be created, as described by the .NET Framework [Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)) documentation.</span></span>  
  
2.  <span data-ttu-id="2c298-186">추가 기능에 대 한 계약 인터페이스를 구현 해야 <xref:System.AddIn.Contract.INativeHandleContract>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-186">The contract interface for the add-in must implement <xref:System.AddIn.Contract.INativeHandleContract>.</span></span>  
  
3.  <span data-ttu-id="2c298-187">호스트 응용 프로그램에 전달 되는 추가 기능에 직접 또는 간접적으로 파생 되어야에서 <xref:System.Windows.FrameworkElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-187">The add-in that is passed to the host application must directly or indirectly derive from <xref:System.Windows.FrameworkElement>.</span></span>  
  
4.  <span data-ttu-id="2c298-188">추가 기능에서 변환 해야는 <xref:System.Windows.FrameworkElement> 에 <xref:System.AddIn.Contract.INativeHandleContract> 격리 경계를 통과 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-188">The add-in must be converted from a <xref:System.Windows.FrameworkElement> to an <xref:System.AddIn.Contract.INativeHandleContract> before crossing the isolation boundary.</span></span>  
  
5.  <span data-ttu-id="2c298-189">추가 기능에서 변환 해야는 <xref:System.AddIn.Contract.INativeHandleContract> 에 <xref:System.Windows.FrameworkElement> 격리 경계를 통과 한 후입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-189">The add-in must be converted from an <xref:System.AddIn.Contract.INativeHandleContract> to a <xref:System.Windows.FrameworkElement> after crossing the isolation boundary.</span></span>  
  
6.  <span data-ttu-id="2c298-190">호스트 응용 프로그램은 반환 된 표시 <xref:System.Windows.FrameworkElement>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-190">The host application displays the returned <xref:System.Windows.FrameworkElement>.</span></span>  
  
 <span data-ttu-id="2c298-191">UI 인 추가 기능을 구현 하는 방법을 보여 주는 예제를 보려면 [는 추가 되는 UI를 만드는](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-191">For an example that demonstrates how to implement an add-in that is a UI, see [Create an Add-In That Is a UI](../../../../docs/framework/wpf/app-development/how-to-create-an-add-in-that-is-a-ui.md).</span></span>  
  
<a name="ReturningMultipleUIsFromAnAddIn"></a>   
## <a name="returning-multiple-uis-from-an-add-in"></a><span data-ttu-id="2c298-192">추가 기능에서 여러 UI 반환</span><span class="sxs-lookup"><span data-stu-id="2c298-192">Returning Multiple UIs from an Add-In</span></span>  
 <span data-ttu-id="2c298-193">추가 기능의 종종 표시할 호스트 응용 프로그램에 대 한 여러 사용자 인터페이스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-193">Add-ins often provide multiple user interfaces for host applications to display.</span></span> <span data-ttu-id="2c298-194">예를 들어의 추가 기능 ui도 UI도 호스트 응용 프로그램에 상태 정보를 제공 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-194">For example, consider an add-in that is a UI that also provides status information to the host application, also as a UI.</span></span> <span data-ttu-id="2c298-195">이와 같은 추가 기능은 [추가 기능이 사용자 인터페이스를 반환함](#ReturnUIFromAddInContract) 및 [추가 기능이 사용자 인터페이스임](#AddInIsAUI) 모델의 기술을 조합하여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-195">An add-in like this can be implemented by using a combination of techniques from both the [Add-In Returns a User Interface](#ReturnUIFromAddInContract) and [Add-In Is a User Interface](#AddInIsAUI) models.</span></span>  
  
<a name="AddInsAndXBAPs"></a>   
## <a name="add-ins-and-xaml-browser-applications"></a><span data-ttu-id="2c298-196">추가 기능 및 XAML 브라우저 애플리케이션</span><span class="sxs-lookup"><span data-stu-id="2c298-196">Add-Ins and XAML Browser Applications</span></span>  
 <span data-ttu-id="2c298-197">지금까지의 예에서는 호스트 애플리케이션이 독립형 애플리케이션으로 설치되었습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-197">In the examples so far, the host application has been an installed standalone application.</span></span> <span data-ttu-id="2c298-198">다음과 같은 추가 빌드 및 구현 요구 사항이 있긴 하지만 [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)]에서도 추가 기능을 호스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-198">But [!INCLUDE[TLA#tla_xbap#plural](../../../../includes/tlasharptla-xbapsharpplural-md.md)] can also host add-ins, albeit with the following additional build and implementation requirements:</span></span>  
  
-   <span data-ttu-id="2c298-199">클라이언트 컴퓨터에서 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]와 동일한 폴더의 [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] 애플리케이션 캐시에 파이프라인(폴더 및 어셈블리) 및 추가 기능 어셈블리를 다운로드하도록 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 애플리케이션 매니페스트를 특별히 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-199">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application manifest must be configured specially to download the pipeline (folders and assemblies) and add-in assembly to the [!INCLUDE[TLA#tla_clickonce](../../../../includes/tlasharptla-clickonce-md.md)] application cache on the client machine, in the same folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span>  
  
-   <span data-ttu-id="2c298-200">추가 기능을 검색하고 로드하는 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 코드가 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]의 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 애플리케이션 캐시를 파이프라인과 추가 기능 위치로 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-200">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code to discover and load add-ins must use the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] application cache for the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] as the pipeline and add-in location.</span></span>  
  
-   <span data-ttu-id="2c298-201">추가 기능이 원본 사이트에 있는 느슨한 파일을 참조하는 경우 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]는 특수 보안 컨텍스트에 추가 기능을 로드해야 합니다. 추가 기능이 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)]에서 호스팅된 경우 이러한 추가 기능은 호스트 애플리케이션의 원본 사이트에 있는 느슨한 파일만 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-201">The [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] must load the add-in into a special security context if the add-in references loose files that are located at the site of origin; when hosted by [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)], add-ins can only reference loose files that are located at the host application's site of origin.</span></span>  
  
 <span data-ttu-id="2c298-202">이러한 작업은 다음 하위 섹션에 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-202">These tasks are described in detail in the following subsections.</span></span>  
  
### <a name="configuring-the-pipeline-and-add-in-for-clickonce-deployment"></a><span data-ttu-id="2c298-203">ClickOnce 배포를 위한 파이프라인 및 추가 기능 구성</span><span class="sxs-lookup"><span data-stu-id="2c298-203">Configuring the Pipeline and Add-In for ClickOnce Deployment</span></span>  
 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)]<span data-ttu-id="2c298-204">는 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 배포 캐시의 안전한 폴더로 다운로드되고 이 폴더에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-204">are downloaded to and run from a safe folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment cache.</span></span> <span data-ttu-id="2c298-205">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]가 추가 기능을 호스트하려면 파이프라인과 추가 기능 어셈블리도 안전한 폴더에 다운로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-205">In order for an [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] to host an add-in, the pipeline and add-in assembly must also be downloaded to the safe folder.</span></span> <span data-ttu-id="2c298-206">이 작업을 수행하려면 다운로드할 파이프라인과 추가 기능 어셈블리를 모두 포함하도록 애플리케이션 매니페스트를 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-206">To achieve this, you need to configure the application manifest to include both the pipeline and add-in assembly for download.</span></span> <span data-ttu-id="2c298-207">[!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]에서 파이프라인 어셈블리를 검색하려면 파이프라인과 추가 기능 어셈블리가 호스트 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 프로젝트의 루트 폴더에 있어야 하지만, 이 작업은 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]에서 가장 쉽게 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-207">This is most easily done in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)], although the pipeline and add-in assembly needs to be in the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root folder in order for [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] to detect the pipeline assemblies.</span></span>  
  
 <span data-ttu-id="2c298-208">결과적으로 첫 번째 단계에서는 각 파이프라인 어셈블리의 빌드 출력과 추가 기능 어셈블리 프로젝트를 설정하여 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 프로젝트의 루트에 파이프라인 및 추가 기능 어셈블리를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-208">Consequently, the first step is to build the pipeline and add-in assembly to the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project's root by setting the build output of each pipeline assembly and add-in assembly projects.</span></span> <span data-ttu-id="2c298-209">다음 표에서는 호스트 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 프로젝트와 동일한 솔루션 및 루트 폴더에 있는 파이프라인 어셈블리 프로젝트와 추가 기능 어셈블리 프로젝트의 빌드 출력 경로를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-209">The following table shows the build output paths for pipeline assembly projects and add-in assembly project that are in the same solution and root folder as the host [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project.</span></span>  
  
 <span data-ttu-id="2c298-210">표 1: XBAP에서 호스트 되는 파이프라인 어셈블리를 빌드 출력 경로</span><span class="sxs-lookup"><span data-stu-id="2c298-210">Table 1: Build Output Paths for the Pipeline Assemblies That Are Hosted by an XBAP</span></span>  
  
|<span data-ttu-id="2c298-211">파이프라인 어셈블리 프로젝트</span><span class="sxs-lookup"><span data-stu-id="2c298-211">Pipeline assembly project</span></span>|<span data-ttu-id="2c298-212">빌드 출력 경로</span><span class="sxs-lookup"><span data-stu-id="2c298-212">Build output path</span></span>|  
|-------------------------------|-----------------------|  
|<span data-ttu-id="2c298-213">계약</span><span class="sxs-lookup"><span data-stu-id="2c298-213">Contract</span></span>|`..\HostXBAP\Contracts\`|  
|<span data-ttu-id="2c298-214">추가 기능 뷰</span><span class="sxs-lookup"><span data-stu-id="2c298-214">Add-In View</span></span>|`..\HostXBAP\AddInViews\`|  
|<span data-ttu-id="2c298-215">추가 기능측 어댑터</span><span class="sxs-lookup"><span data-stu-id="2c298-215">Add-In-Side Adapter</span></span>|`..\HostXBAP\AddInSideAdapters\`|  
|<span data-ttu-id="2c298-216">호스트측 어댑터</span><span class="sxs-lookup"><span data-stu-id="2c298-216">Host-Side Adapter</span></span>|`..\HostXBAP\HostSideAdapters\`|  
|<span data-ttu-id="2c298-217">추가 기능</span><span class="sxs-lookup"><span data-stu-id="2c298-217">Add-In</span></span>|`..\HostXBAP\AddIns\WPFAddIn1`|  
  
 <span data-ttu-id="2c298-218">다음 단계에서는 다음을 수행하여 파이프라인 어셈블리와 추가 기능 어셈블리를 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]의 [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] 콘텐츠 파일로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-218">The next step is to specify the pipeline assemblies and add-in assembly as the [!INCLUDE[TLA2#tla_xbap#plural](../../../../includes/tla2sharptla-xbapsharpplural-md.md)] content files in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="2c298-219">솔루션 탐색기에서 각 파이프라인 폴더를 마우스 오른쪽 단추로 클릭하고 **프로젝트에 포함**을 선택하여 프로젝트에 파이프라인 및 추가 기능 어셈블리 포함.</span><span class="sxs-lookup"><span data-stu-id="2c298-219">Including the pipeline and add-in assembly in the project by right-clicking each pipeline folder in Solution Explorer and choosing **Include In Project**.</span></span>  
  
2.  <span data-ttu-id="2c298-220">**속성** 창에서 각 파이프라인 어셈블리 및 추가 기능 어셈블리의 **빌드 작업**을 **콘텐츠**로 설정.</span><span class="sxs-lookup"><span data-stu-id="2c298-220">Setting the **Build Action** of each pipeline assembly and add-in assembly to **Content** from the **Properties** window.</span></span>  
  
 <span data-ttu-id="2c298-221">마지막 단계에서는 다운로드할 파이프라인 어셈블리 파일과 추가 기능 어셈블리 파일을 포함하도록 애플리케이션 매니페스트를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-221">The final step is to configure the application manifest to include the pipeline assembly files and add-in assembly file for download.</span></span> <span data-ttu-id="2c298-222">파일은 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 애플리케이션이 차지하는 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 캐시의 폴더 루트에 있는 폴더에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-222">The files should be located in folders at the root of the folder in the [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache that the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] application occupies.</span></span> <span data-ttu-id="2c298-223">구성은 [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)]에서 다음을 수행하여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-223">The configuration can be achieved in [!INCLUDE[TLA2#tla_visualstu](../../../../includes/tla2sharptla-visualstu-md.md)] by doing the following:</span></span>  
  
1.  <span data-ttu-id="2c298-224">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 프로젝트를 마우스 오른쪽 단추로 클릭하고, **속성**, **게시** 순으로 클릭한 다음 **응용 프로그램 파일** 단추를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-224">Right-click the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] project, click **Properties**, click **Publish**, and then click the **Application Files** button.</span></span>  
  
2.  <span data-ttu-id="2c298-225">**응용 프로그램 파일** 대화 상자에서 각 파이프라인과 추가 기능 DLL의 **게시 상태**를 **포함(자동)** 으로 설정하고 각 파이프라인과 추가 기능 DLL에 대해 **그룹 다운로드**을 **(필수)** 로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-225">In the **Application Files** dialog, set the **Publish Status** of each pipeline and add-in DLL to **Include (Auto)**, and set the **Download Group** for each pipeline and add-in DLL to **(Required)**.</span></span>  
  
### <a name="using-the-pipeline-and-add-in-from-the-application-base"></a><span data-ttu-id="2c298-226">애플리케이션 기준 위치에서 파이프라인과 추가 기능 사용</span><span class="sxs-lookup"><span data-stu-id="2c298-226">Using the Pipeline and Add-In from the Application Base</span></span>  
 <span data-ttu-id="2c298-227">파이프라인 및 추가 기능이 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 배포용으로 구성되면 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]와 동일한 [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] 캐시 폴더에 다운로드됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-227">When the pipeline and add-in are configured for [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] deployment, they are downloaded to the same [!INCLUDE[TLA2#tla_clickonce](../../../../includes/tla2sharptla-clickonce-md.md)] cache folder as the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)].</span></span> <span data-ttu-id="2c298-228">[!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)]의 파이프라인과 추가 기능을 사용하려면 [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] 코드를 통해 응용 프로그램 기준 위치에서 가져와야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-228">To use the pipeline and add-in from the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)], the [!INCLUDE[TLA2#tla_xbap](../../../../includes/tla2sharptla-xbap-md.md)] code must get them from the application base.</span></span> <span data-ttu-id="2c298-229">다양 한 형식 및 멤버의.NET Framework 추가 기능에서 모델 파이프라인과 추가 기능을 사용 하 여이 시나리오에 대 한 특별 한 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-229">The various types and members of the .NET Framework add-in model for using pipelines and add-ins provide special support for this scenario.</span></span> <span data-ttu-id="2c298-230">경로으로 식별 되는 먼저는 <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> 열거형 값입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-230">Firstly, the path is identified by the <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> enumeration value.</span></span> <span data-ttu-id="2c298-231">다음을 포함하는 파이프라인을 사용하기 위해 관련 추가 기능 멤버의 오버로드와 함께 이 값을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-231">You use this value with overloads of the pertinent add-in members for using pipelines that include the following:</span></span>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.FindAddIns%28System.Type%2CSystem.AddIn.Hosting.PipelineStoreLocation%2CSystem.String%5B%5D%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Rebuild%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
-   <xref:System.AddIn.Hosting.AddInStore.Update%28System.AddIn.Hosting.PipelineStoreLocation%29?displayProperty=nameWithType>  
  
### <a name="accessing-the-hosts-site-of-origin"></a><span data-ttu-id="2c298-232">호스트의 원본 사이트에 액세스</span><span class="sxs-lookup"><span data-stu-id="2c298-232">Accessing the Host's Site of Origin</span></span>  
 <span data-ttu-id="2c298-233">추가 기능이 원본 사이트의 파일을 참조할 수 있도록 호스트 애플리케이션과 동일한 수준의 보안 격리로 추가 기능을 로드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-233">To ensure that an add-in can reference files from the site of origin, the add-in must be loaded with security isolation that is equivalent to the host application.</span></span> <span data-ttu-id="2c298-234">이 보안 수준으로 식별 되는 <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> 열거형 값을 전달할는 <xref:System.AddIn.Hosting.AddInToken.Activate%2A> 메서드 추가 기능이 활성화 되는 경우.</span><span class="sxs-lookup"><span data-stu-id="2c298-234">This security level is identified by the <xref:System.AddIn.Hosting.AddInSecurityLevel.Host?displayProperty=nameWithType> enumeration value, and passed to the <xref:System.AddIn.Hosting.AddInToken.Activate%2A> method when an add-in is activated.</span></span>  
  
<a name="WPFAddInModelArchitecture"></a>   
## <a name="wpf-add-in-architecture"></a><span data-ttu-id="2c298-235">WPF 추가 기능 아키텍처</span><span class="sxs-lookup"><span data-stu-id="2c298-235">WPF Add-In Architecture</span></span>  
 <span data-ttu-id="2c298-236">높은 수준에서 앞서 설명한 것 처럼 WPF를 통해 사용자 인터페이스를 구현 하려면.NET Framework 추가 기능 (에서 직접 또는 간접적으로 파생 된 <xref:System.Windows.FrameworkElement>)를 사용 하 여 <xref:System.AddIn.Contract.INativeHandleContract>를 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> 및 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-236">At the highest level, as we've seen, WPF enables .NET Framework add-ins to implement user interfaces (that derive directly or indirectly from <xref:System.Windows.FrameworkElement>) using <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A>.</span></span> <span data-ttu-id="2c298-237">결과 호스트 응용 프로그램 반환 되는 <xref:System.Windows.FrameworkElement> 호스트 응용 프로그램의 UI에서 표시 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-237">The result is that the host application is returned a <xref:System.Windows.FrameworkElement> that is displayed from UI in the host application.</span></span>  
  
 <span data-ttu-id="2c298-238">간단한 UI 추가 기능 시나리오에 대 한 세부 정보를 개발자에 게 필요한 만큼 이것이입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-238">For simple UI add-in scenarios, this is as much detail as a developer needs.</span></span> <span data-ttu-id="2c298-239">특히 레이아웃, 리소스 및 데이터 바인딩 같은 WPF 서비스를 이용 하는 복잡 한 시나리오에 대 한 그 장점을 파악 하기 위해 WPF는 UI 지원은.NET Framework 추가 기능 모델을 확장 하는 방법의 자세한 기술 사항은 및 제한 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-239">For more complex scenarios, particularly those that try to utilize additional WPF services such as layout, resources, and data binding, more detailed knowledge of how WPF extends the .NET Framework add-in model with UI support is required to understand its benefits and limitations.</span></span>  
  
 <span data-ttu-id="2c298-240">근본적으로 WPF 통과 하지 못한 UI 추가 기능에서 호스트 응용 프로그램입니다. 대신 WPF WPF 상호 운용성을 사용 하 여 UI에 대 한 Win32 창 핸들을 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-240">Fundamentally, WPF doesn't pass a UI from an add-in to a host application; instead, WPF passes the Win32 window handle for the UI by using WPF interoperability.</span></span> <span data-ttu-id="2c298-241">따라서 UI 추가 기능에서 호스트 응용 프로그램에 전달 되는 다음 작업이 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-241">As such, when a UI from an add-in is passed to a host application, the following occurs:</span></span>  
  
-   <span data-ttu-id="2c298-242">추가 기능 쪽에서 WPF 호스트 응용 프로그램에서 표시 되는 UI에 대 한 창 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-242">On the add-in side, WPF acquires a window handle for the UI that will be displayed by the host application.</span></span> <span data-ttu-id="2c298-243">창 핸들에서 파생 되는 내부 WPF 클래스에 의해 캡슐화 되 <xref:System.Windows.Interop.HwndSource> 구현 및 <xref:System.AddIn.Contract.INativeHandleContract>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-243">The window handle is encapsulated by an internal WPF class that derives from <xref:System.Windows.Interop.HwndSource> and implements <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="2c298-244">이 클래스의 인스턴스 반환한 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> 응용 프로그램 도메인에 대 한 추가 기능에서 호스트 응용 프로그램의 응용 프로그램 도메인으로 마샬링됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-244">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> and is marshaled from the add-in's application domain to the host application's application domain.</span></span>  
  
-   <span data-ttu-id="2c298-245">WPF 호스트 응용 프로그램 쪽에서 가져오며 합니다 <xref:System.Windows.Interop.HwndSource> 에서 파생 되는 내부 WPF 클래스로 <xref:System.Windows.Interop.HwndHost> 들고 <xref:System.AddIn.Contract.INativeHandleContract>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-245">On the host application side, WPF repackages the <xref:System.Windows.Interop.HwndSource> as an internal WPF class that derives from <xref:System.Windows.Interop.HwndHost> and consumes <xref:System.AddIn.Contract.INativeHandleContract>.</span></span> <span data-ttu-id="2c298-246">이 클래스의 인스턴스 반환한 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> 호스트 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-246">An instance of this class is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the host application.</span></span>  
  
 <span data-ttu-id="2c298-247"><xref:System.Windows.Interop.HwndHost> WPF 사용자 인터페이스에서 창 핸들을 통해 식별 되는 사용자 인터페이스를 표시 하기 위해 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-247"><xref:System.Windows.Interop.HwndHost> exists to display user interfaces, identified by window handles, from WPF user interfaces.</span></span> <span data-ttu-id="2c298-248">자세한 내용은 [WPF 및 Win32 상호 운용성](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="2c298-248">For more information, see [WPF and Win32 Interoperation](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).</span></span>  
  
 <span data-ttu-id="2c298-249">요약 하자면, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, 및 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> 전달할 추가 기능에서 호스트 응용 프로그램에 의해 캡슐화 되는 WPF UI의 창 핸들을 허용 하기 위해 존재는 <xref:System.Windows.Interop.HwndHost> 호스트 응용 프로그램의 UI를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-249">In summary, <xref:System.AddIn.Contract.INativeHandleContract>, <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>, and <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> exist to allow the window handle for a WPF UI to be passed from an add-in to a host application, where it is encapsulated by a <xref:System.Windows.Interop.HwndHost> and displayed the host application's UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2c298-250">호스트 응용 프로그램 때문에 <xref:System.Windows.Interop.HwndHost>, 호스트 응용 프로그램에서 반환 되는 개체를 변환할 수 없습니다 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> 형식으로 추가 기능에서 구현 됩니다 (예를 들어를 <xref:System.Windows.Controls.UserControl>).</span><span class="sxs-lookup"><span data-stu-id="2c298-250">Because the host application gets an <xref:System.Windows.Interop.HwndHost>, the host application cannot convert the object that is returned by <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ContractToViewAdapter%2A> to the type it is implemented as by the add-in (for example, a <xref:System.Windows.Controls.UserControl>).</span></span>  
  
 <span data-ttu-id="2c298-251">기본적으로 <xref:System.Windows.Interop.HwndHost> 호스트 응용 프로그램 수 사용 하는 방법에 영향을 주는 특정 제한 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-251">By its nature, <xref:System.Windows.Interop.HwndHost> has certain limitations that affect how host applications can use them.</span></span> <span data-ttu-id="2c298-252">그러나 WPF는 확장 <xref:System.Windows.Interop.HwndHost> 추가 기능 시나리오에 대 한 몇 가지 기능을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-252">However, WPF extends <xref:System.Windows.Interop.HwndHost> with several capabilities for add-in scenarios.</span></span> <span data-ttu-id="2c298-253">이러한 이점과 한계는 아래에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-253">These benefits and limitations are described below.</span></span>  
  
<a name="WPFAddInModelBenefits"></a>   
## <a name="wpf-add-in-benefits"></a><span data-ttu-id="2c298-254">WPF 추가 기능의 이점</span><span class="sxs-lookup"><span data-stu-id="2c298-254">WPF Add-In Benefits</span></span>  
 <span data-ttu-id="2c298-255">WPF 추가 기능 사용자 인터페이스에서 파생 되는 내부 클래스를 사용 하 여 호스트 응용 프로그램에서 표시 되기 때문 <xref:System.Windows.Interop.HwndHost>, 해당 사용자 인터페이스의 기능에 의해 제한 됩니다 <xref:System.Windows.Interop.HwndHost> 레이아웃와 같은 WPF UI 서비스와 관련 하 여 렌더링, 데이터 바인딩, 스타일, 템플릿 및 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-255">Because WPF add-in user interfaces are displayed from host applications using an internal class that derives from <xref:System.Windows.Interop.HwndHost>, those user interfaces are constrained by the capabilities of <xref:System.Windows.Interop.HwndHost> with respect to WPF UI services such as layout, rendering, data binding, styles, templates, and resources.</span></span> <span data-ttu-id="2c298-256">그러나 WPF 보강 내부 <xref:System.Windows.Interop.HwndHost> 다음을 포함 하는 추가 기능을 사용 하 여 하위 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-256">However, WPF augments its internal <xref:System.Windows.Interop.HwndHost> subclass with additional capabilities that include the following:</span></span>  
  
-   <span data-ttu-id="2c298-257">호스트 응용 프로그램의 UI 및 추가 기능에서 UI 간 탭 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-257">Tabbing between a host application's UI and an add-in's UI.</span></span> <span data-ttu-id="2c298-258">"추가-UI 임" 프로그래밍 모델에서는 재정의를 추가 기능 쪽 어댑터는 <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> 추가-신뢰할 수 있는 완벽 하 게 되는지 아니면 부분적으로 신뢰할 수 있는 탭을 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-258">Note that the "add-in is a UI" programming model requires the add-in-side adapter to override <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> to enable tabbing, whether the add-in is fully trusted or partially trusted.</span></span>  
  
-   <span data-ttu-id="2c298-259">호스트 응용 프로그램 사용자 인터페이스에서 표시 되는 추가 기능 사용자 인터페이스에 대 한 접근성 요구 사항 준수 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-259">Honoring accessibility requirements for add-in user interfaces that are displayed from host application user interfaces.</span></span>  
  
-   <span data-ttu-id="2c298-260">WPF 응용 프로그램의 여러 응용 프로그램 도메인 시나리오에서 안전 하 게 실행을 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-260">Enabling WPF applications to run safely in multiple application domain scenarios.</span></span>  
  
-   <span data-ttu-id="2c298-261">추가 기능 보안 격리 (즉, 부분 신뢰 보안 샌드박스)를 사용 하 여 실행 하는 경우 창 처리 UI 추가 기능에 대 한 무단 액세스를 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-261">Preventing illegal access to add-in UI window handles when add-ins run with security isolation (that is, a partial-trust security sandbox).</span></span> <span data-ttu-id="2c298-262">호출 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> 이 보안을 위해:</span><span class="sxs-lookup"><span data-stu-id="2c298-262">Calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> ensures this security:</span></span>  
  
    -   <span data-ttu-id="2c298-263">"추가 UI를 반환" 프로그래밍 모델에 대 한 격리 경계를 넘어 추가 UI의 창 핸들을 전달 하는 유일한 방법은 호출 방법은 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-263">For the "add-in returns a UI" programming model, the only way to pass the window handle for an add-in UI across the isolation boundary is to call <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A>.</span></span>  
  
    -   <span data-ttu-id="2c298-264">"추가-UI 임" 프로그래밍 모델에 대 한 재정의 <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> 추가 기능 쪽 어댑터 및 전화 <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (앞의 예제에 표시 된 것)는 필요한 경우 추가 기능 쪽 어댑터를 호출 하는 대로 `QueryContract` 구현을 호스트 쪽 어댑터입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-264">For the "add-in is a UI" programming model, overriding <xref:System.AddIn.Pipeline.ContractBase.QueryContract%2A> on the add-in-side adapter and calling <xref:System.AddIn.Pipeline.FrameworkElementAdapters.ViewToContractAdapter%2A> (as shown in the preceding examples) is required, as is calling the add-in-side adapter's `QueryContract` implementation from the host-side adapter.</span></span>  
  
-   <span data-ttu-id="2c298-265">여러 애플리케이션 도메인 실행 보호 제공.</span><span class="sxs-lookup"><span data-stu-id="2c298-265">Providing multiple application domain execution protection.</span></span> <span data-ttu-id="2c298-266">애플리케이션 도메인의 한계로 인해 추가 기능 애플리케이션 도메인에서 throw된 처리되지 않은 예외가 발생하면 격리 경계가 있는 경우에도 전체 애플리케이션이 중단됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-266">Due to limitations with application domains, unhandled exceptions that are thrown in add-in application domains cause the entire application to crash, even though the isolation boundary exists.</span></span> <span data-ttu-id="2c298-267">그러나 WPF 및.NET Framework 추가 기능 모델에는이 문제를 해결 하 고 응용 프로그램 안정성을 개선 하는 간단한 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-267">However, WPF and the .NET Framework add-in model provide a simple way to work around this problem and improve application stability.</span></span> <span data-ttu-id="2c298-268">WPF 추가 기능에서 UI를 표시 하는 만드는 <xref:System.Windows.Threading.Dispatcher> 호스트 응용 프로그램은 WPF 응용 프로그램을 하는 경우 응용 프로그램 도메인에 실행 되는 스레드에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-268">A WPF add-in that displays a UI creates a <xref:System.Windows.Threading.Dispatcher> for the thread that the application domain runs on, if the host application is a WPF application.</span></span> <span data-ttu-id="2c298-269">처리 하 여 응용 프로그램 도메인에서 발생 하는 처리 되지 않은 모든 예외를 감지할 수 있습니다 합니다 <xref:System.Windows.Threading.Dispatcher.UnhandledException> 이벤트의 WPF 추가 기능의 <xref:System.Windows.Threading.Dispatcher>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-269">You can detect all unhandled exceptions that occur in the application domain by handling the <xref:System.Windows.Threading.Dispatcher.UnhandledException> event of the WPF add-in's <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="2c298-270">가져올 수 있습니다 합니다 <xref:System.Windows.Threading.Dispatcher> 에서 <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-270">You can get the <xref:System.Windows.Threading.Dispatcher> from the <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> property.</span></span>  
  
<a name="WPFAddInModelLimitations"></a>   
## <a name="wpf-add-in-limitations"></a><span data-ttu-id="2c298-271">WPF 추가 기능 한계</span><span class="sxs-lookup"><span data-stu-id="2c298-271">WPF Add-In Limitations</span></span>  
 <span data-ttu-id="2c298-272">WPF에서 제공 하는 기본 동작을 추가 하는 이점 외 <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, 창 핸들 및 호스트 응용 프로그램에서 표시 되는 추가 기능 사용자 인터페이스에 대 한 제한도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-272">Beyond the benefits that WPF adds to the default behaviors supplied by <xref:System.Windows.Interop.HwndSource>, <xref:System.Windows.Interop.HwndHost>, and window handles, there are also limitations for add-in user interfaces that are displayed from host applications:</span></span>  
  
-   <span data-ttu-id="2c298-273">호스트 응용 프로그램에서 표시 하는 추가 기능 사용자 인터페이스는 호스트 응용 프로그램의 클리핑 동작을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-273">Add-in user interfaces displayed from a host application do not respect the host application's clipping behavior.</span></span>  
  
-   <span data-ttu-id="2c298-274">상호 운용성 시나리오의 *에어스페이스* 개념도 추가 기능에 적용됩니다([기술 영역 개요](../../../../docs/framework/wpf/advanced/technology-regions-overview.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="2c298-274">The concept of *airspace* in interoperability scenarios also applies to add-ins (see [Technology Regions Overview](../../../../docs/framework/wpf/advanced/technology-regions-overview.md)).</span></span>  
  
-   <span data-ttu-id="2c298-275">리소스 상속, 데이터 바인딩 및 명령과 추가 기능에 자동으로 제공 됩니다. 같은 호스트 응용 프로그램의 UI 서비스 사용자 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-275">A host application's UI services, such as resource inheritance, data binding, and commanding, are not automatically available to add-in user interfaces.</span></span> <span data-ttu-id="2c298-276">추가 기능에 이러한 서비스를 제공하려면 파이프라인을 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-276">To provide these services to the add-in, you need to update the pipeline.</span></span>  
  
-   <span data-ttu-id="2c298-277">추가 UI를를 회전, 크기를 조정, 기울이기, 또는 그렇지 않은 경우 변환의 영향을 받는 수 없습니다 (참조 [변환 개요](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="2c298-277">An add-in UI cannot be rotated, scaled, skewed, or otherwise affected by a transformation (see [Transforms Overview](../../../../docs/framework/wpf/graphics-multimedia/transforms-overview.md)).</span></span>  
  
-   <span data-ttu-id="2c298-278">작업을 그려 렌더링 되는 추가 기능 사용자 인터페이스 내의 콘텐츠는 <xref:System.Drawing> 알파 혼합 네임 스페이스를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-278">Content inside add-in user interfaces that is rendered by drawing operations from the <xref:System.Drawing> namespace can include alpha blending.</span></span> <span data-ttu-id="2c298-279">그러나 포함 하는 UI의 호스트 응용 프로그램과 추가 기능에서 UI를 100% 여야 불투명 합니다. 즉,는 `Opacity` 둘 다에서 속성을 1로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-279">However, both an add-in UI and the host application UI that contains it must be 100% opaque; in other words, the `Opacity` property on both must be set to 1.</span></span>  
  
-   <span data-ttu-id="2c298-280">경우는 <xref:System.Windows.Window.AllowsTransparency%2A> 추가 UI를 포함 하는 호스트 응용 프로그램에서 창의 속성이 `true`, 추가 기능에서 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-280">If the <xref:System.Windows.Window.AllowsTransparency%2A> property of a window in the host application that contains an add-in UI is set to `true`, the add-in is invisible.</span></span> <span data-ttu-id="2c298-281">추가 UI가 100% 불투명 하는 경우에 마찬가지입니다 (즉,는 `Opacity` 속성에 값이 1).</span><span class="sxs-lookup"><span data-stu-id="2c298-281">This is true even if the add-in UI is 100% opaque (that is, the `Opacity` property has a value of 1).</span></span>  
  
-   <span data-ttu-id="2c298-282">추가 UI를 동일한 최상위 창의 다른 WPF 요소 위에 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-282">An add-in UI must appear on top of other WPF elements in the same top-level window.</span></span>  
  
-   <span data-ttu-id="2c298-283">사용 하 여 추가 기능에서 UI 없는 부분을 렌더링할 수 있습니다는 <xref:System.Windows.Media.VisualBrush>합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-283">No portion of an add-in's UI can be rendered using a <xref:System.Windows.Media.VisualBrush>.</span></span> <span data-ttu-id="2c298-284">대신, 추가 계약으로 정의 된 메서드를 사용 하 여 호스트 응용 프로그램에 전달할 수 있는 비트맵을 만들려면 생성 된 UI의 스냅숏으로 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-284">Instead, the add-in may take a snapshot of the generated UI to create a bitmap that can be passed to the host application using methods defined by the contract.</span></span>  
  
-   <span data-ttu-id="2c298-285">미디어 파일을 재생할 수 없습니다는 <xref:System.Windows.Controls.MediaElement> 추가 UI에서.</span><span class="sxs-lookup"><span data-stu-id="2c298-285">Media files cannot be played from a <xref:System.Windows.Controls.MediaElement> in an add-in UI.</span></span>  
  
-   <span data-ttu-id="2c298-286">마우스 이벤트 추가 UI에 대해 생성 된 받은 아니고 호스트 응용 프로그램에서 발생 하며 `IsMouseOver` 호스트 응용 프로그램 UI에 대 한 속성의 값이 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-286">Mouse events generated for the add-in UI are neither received nor raised by the host application, and the `IsMouseOver` property for host application UI has a value of `false`.</span></span>  
  
-   <span data-ttu-id="2c298-287">추가 UI의 컨트롤 간에 포커스가 이동할 때 합니다 `GotFocus` 및 `LostFocus` 이벤트 수신 아니고 호스트 응용 프로그램에 의해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-287">When focus shifts between controls in an add-in UI, the `GotFocus` and `LostFocus` events are neither received nor raised by the host application.</span></span>  
  
-   <span data-ttu-id="2c298-288">추가 UI를 포함 하는 호스트 응용 프로그램의 부분 인쇄 시 흰색으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-288">The portion of a host application that contains an add-in UI appears white when printed.</span></span>  
  
-   <span data-ttu-id="2c298-289">모든 디스패처 (참조 <xref:System.Windows.Threading.Dispatcher>) 추가 기능을 통해 만든 UI를 종료 해야 합니다 수동으로 소유자 추가 기능에서 언로드되기 전에 호스트 응용 프로그램 실행을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-289">All dispatchers (see <xref:System.Windows.Threading.Dispatcher>) created by the add-in UI must be shut down manually before the owner add-in is unloaded if the host application continues execution.</span></span> <span data-ttu-id="2c298-290">계약 추가 언로드되기 전에, 해당 디스패처를 종료 하려면 추가 UI 있기 때문에 추가 기능에 알리기 위해 호스트 응용 프로그램을 사용할 수 있는 메서드를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-290">The contract can implement methods that allow the host application to signal the add-in before the add-in is unloaded, thereby allowing the add-in UI to shut down its dispatchers.</span></span>  
  
-   <span data-ttu-id="2c298-291">추가 UI를 경우는 <xref:System.Windows.Controls.InkCanvas> 같거나는 <xref:System.Windows.Controls.InkCanvas>, 추가 기능에서 언로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-291">If an add-in UI is an <xref:System.Windows.Controls.InkCanvas> or contains an <xref:System.Windows.Controls.InkCanvas>, you cannot unload the add-in.</span></span>  
  
<a name="PerformanceOptimization"></a>   
## <a name="performance-optimization"></a><span data-ttu-id="2c298-292">성능 최적화</span><span class="sxs-lookup"><span data-stu-id="2c298-292">Performance Optimization</span></span>  
 <span data-ttu-id="2c298-293">기본적으로 여러 응용 프로그램 도메인을 사용 하는 경우 각 응용 프로그램에 필요한 다양 한.NET Framework 어셈블리는 모든 도메인에 로드 해당 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="2c298-293">By default, when multiple application domains are used, the various .NET Framework assemblies required by each application are all loaded into that application's domain.</span></span> <span data-ttu-id="2c298-294">결과적으로 새 애플리케이션 도메인을 만들고 이 도메인의 애플리케이션을 시작하는 데 필요한 시간이 성능에 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-294">As a result, the time required for creating new application domains and starting applications in them might affect performance.</span></span> <span data-ttu-id="2c298-295">그러나.NET Framework 응용 프로그램을 이미 로드 된 경우 응용 프로그램 도메인 간에 어셈블리를 공유 하도록 지시 하 여 시작 시간을 줄일 수 있는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="2c298-295">However, the .NET Framework provides a way for you to reduce start times by instructing applications to share assemblies across application domains if they are already loaded.</span></span> <span data-ttu-id="2c298-296">사용 하 여이 작업을 수행 합니다 <xref:System.LoaderOptimizationAttribute> 진입점 메서드를 적용 해야 하는 특성 (`Main`).</span><span class="sxs-lookup"><span data-stu-id="2c298-296">You do this by using the <xref:System.LoaderOptimizationAttribute> attribute, which must be applied to the entry point method (`Main`).</span></span> <span data-ttu-id="2c298-297">이 경우, 애플리케이션 정의를 구현하는 코드만 사용해야 합니다([애플리케이션 관리 개요](../../../../docs/framework/wpf/app-development/application-management-overview.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="2c298-297">In this case, you must use only code to implement your application definition (see [Application Management Overview](../../../../docs/framework/wpf/app-development/application-management-overview.md)).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2c298-298">참고자료</span><span class="sxs-lookup"><span data-stu-id="2c298-298">See also</span></span>
- <xref:System.LoaderOptimizationAttribute>
- <span data-ttu-id="2c298-299">[추가 기능 및 확장성](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span><span class="sxs-lookup"><span data-stu-id="2c298-299">[Add-ins and Extensibility](/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100))</span></span>
- [<span data-ttu-id="2c298-300">응용 프로그램 도메인</span><span class="sxs-lookup"><span data-stu-id="2c298-300">Application Domains</span></span>](../../../../docs/framework/app-domains/application-domains.md)
- <span data-ttu-id="2c298-301">[.NET framework Remoting 개요](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="2c298-301">[.NET Framework Remoting Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))</span></span>
- <span data-ttu-id="2c298-302">[개체 사용 가능](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="2c298-302">[Making Objects Remotable](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/wcf3swha(v=vs.100))</span></span>
- [<span data-ttu-id="2c298-303">방법 항목</span><span class="sxs-lookup"><span data-stu-id="2c298-303">How-to Topics</span></span>](../../../../docs/framework/wpf/app-development/how-to-topics.md)
