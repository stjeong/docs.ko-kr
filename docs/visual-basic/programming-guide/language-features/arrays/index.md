---
title: Visual Basic의 배열
ms.date: 12/06/2017
f1_keywords:
- vb.Array
helpviewer_keywords:
- arrays [Visual Basic]
- Visual Basic, arrays
ms.assetid: dbf29737-b589-4443-bee6-a27588d9c67e
ms.openlocfilehash: bb6cb846a305e618a4a0cbf1d4b3d2510df14cf7
ms.sourcegitcommit: c93fd5139f9efcf6db514e3474301738a6d1d649
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/27/2018
ms.locfileid: "50183830"
---
# <a name="arrays-in-visual-basic"></a><span data-ttu-id="4c303-102">Visual Basic의 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-102">Arrays in Visual Basic</span></span>
<span data-ttu-id="4c303-103">배열 라고 하는 값의 집합이 *요소*, 서로 논리적으로 관련이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-103">An array is a set of values, which are termed *elements*, that are logically related to each other.</span></span> <span data-ttu-id="4c303-104">예를 들어, 배열; 초등학교에서 각 학년의 학생 수가 구성 될 수 있습니다. 배열의 각 요소에는 단일 학년의 학생 수입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-104">For example, an array may consist of the number of students in each grade in a grammar school; each element of the array is the number of students in a single grade.</span></span> <span data-ttu-id="4c303-105">마찬가지로, 클래스에 대 한 학생의 성적 배열을 구성 될 수 있습니다. 배열의 각 요소에는 단일 등급입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-105">Similarly, an array may consist of a student's grades for a class; each element of the array is a single grade.</span></span>    

<span data-ttu-id="4c303-106">각 데이터 항목이 저장 가능한 개별 변수 이며</span><span class="sxs-lookup"><span data-stu-id="4c303-106">It is possible individual variables to store each of our data items.</span></span> <span data-ttu-id="4c303-107">예를 들어, 응용 프로그램 분석 학생 점수를 사용할 수 있습니다 별도 변수로 각 학생의 등급이 대 한 같은 `englishGrade1`, `englishGrade2`등입니다. 이 방법에는 세 가지 주요 제한 사항:</span><span class="sxs-lookup"><span data-stu-id="4c303-107">For example, if our application analyzes student grades, we can use a separate variable for each student's grade, such as `englishGrade1`, `englishGrade2`, etc. This approach has three major limitations:</span></span>
- <span data-ttu-id="4c303-108">처리할 수 있다고 얼마나 많은 등급 정확 하 게 디자인 타임에 인식 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-108">We have to know at design time exactly how many grades we have to handle.</span></span>
- <span data-ttu-id="4c303-109">많은 수의 등급을 신속 하 게 처리 하기 힘들어집니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-109">Handling large numbers of grades quickly becomes unwieldy.</span></span> <span data-ttu-id="4c303-110">이 응용 프로그램을에 심각한 버그가 있을 가능성이 훨씬 더를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-110">This in turn makes an application much more likely to have serious bugs.</span></span>
- <span data-ttu-id="4c303-111">유지 관리 하는 것이 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-111">It is difficult to maintain.</span></span> <span data-ttu-id="4c303-112">추가 하는 각 새 엔터프라이즈급 응용 프로그램 수 수정, 다시 컴파일 및 다시 배포는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-112">Each new grade that we add requires that the application be modified, recompiled, and redeployed.</span></span>  
 
 <span data-ttu-id="4c303-113">배열을 사용 하 여 동일한 이름으로 이러한 관련된 값을 참조할 고 라고 하는 숫자를 사용할 수 있습니다는 *인덱스* 하거나 *첨자* 배열에서 해당 위치에 따라 개별 요소를 식별 하기.</span><span class="sxs-lookup"><span data-stu-id="4c303-113">By using an array, you can refer to these related values by the same name, and use a number that’s called an *index* or *subscript* to identify an individual element based on its position in the array.</span></span> <span data-ttu-id="4c303-114">배열 범위를 0에서 1을 뺀 총 수가 배열의 요소의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-114">The indexes of an array range from 0 to one less than the total number of elements in the array.</span></span> <span data-ttu-id="4c303-115">Visual Basic 구문을 사용 하 여 배열의 크기를 정의 하는 경우 총 배열의 요소 수가 아니라 가장 높은 인덱스를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-115">When you use Visual Basic syntax to define the size of an array, you specify its highest index, not the total number of elements in the array.</span></span> <span data-ttu-id="4c303-116">하나의 단위로 배열을 사용 하 여 작업할 수 및 해당 요소를 반복 하는 기능 디자인 타임에 포함 하는 정확 하 게 얼마나 많은 요소입니다. 알 필요가 없도록 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-116">You can work with the array as a unit, and the ability to iterate its elements frees you from needing to know exactly how many elements it contains at design time.</span></span>
  
 <span data-ttu-id="4c303-117">설명하기 전에 몇 가지 빠른 예제는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-117">Some quick examples before explanation:</span></span>  
  
```vb  
' Declare a single-dimension array of 5 numbers.  
Dim numbers(4) As Integer   
  
'Declare a single-dimension array and set its 4 values.  
Dim numbers = New Integer() {1, 2, 4, 8}  
  
' Change the size of an existing array to 16 elements and retain the current values.
ReDim Preserve numbers(15)
  
' Redefine the size of an existing array and reset the values.
ReDim numbers(15)  
  
' Declare a 6 x 6 multidimensional array.
Dim matrix(5, 5) As Double  
  
' Declare a 4 x 3 multidimensional array and set array element values.  
Dim matrix = New Integer(3, 2) {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}  
  
' Declare a jagged array  
Dim sales()() As Double = New Double(11)() {}  
```  
  
 ## <a name="in-this-article"></a><span data-ttu-id="4c303-118">이 문서의 내용</span><span class="sxs-lookup"><span data-stu-id="4c303-118">In this article</span></span>
  
- [<span data-ttu-id="4c303-119">차원 배열의 배열 요소</span><span class="sxs-lookup"><span data-stu-id="4c303-119">Array elements in a simple array</span></span>](#array-elements-in-a-simple-array)  
  
- [<span data-ttu-id="4c303-120">배열 만들기</span><span class="sxs-lookup"><span data-stu-id="4c303-120">Creating an array</span></span>](#creating-an-array)  
  
- [<span data-ttu-id="4c303-121">배열에 값 저장</span><span class="sxs-lookup"><span data-stu-id="4c303-121">Storing values in an array</span></span>](#storing-values-in-an-array)  
  
- [<span data-ttu-id="4c303-122">배열 리터럴 사용 하 여 배열 채우기</span><span class="sxs-lookup"><span data-stu-id="4c303-122">Populating an array with array literals</span></span>](#populating-an-array-with-array-literals)  
  
- [<span data-ttu-id="4c303-123">배열 반복</span><span class="sxs-lookup"><span data-stu-id="4c303-123">Iterating through an array</span></span>](#iterating-through-an-array)  
  
- [<span data-ttu-id="4c303-124">배열 크기</span><span class="sxs-lookup"><span data-stu-id="4c303-124">Array size</span></span>](#BKMK_ArraySize)  

- [<span data-ttu-id="4c303-125">배열 형식</span><span class="sxs-lookup"><span data-stu-id="4c303-125">The array type</span></span>](#the-array-type)  
  
- [<span data-ttu-id="4c303-126">반환 값 및 매개 변수로 사용 되는 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-126">Arrays as return values and parameters</span></span>](#arrays-as-return-values-and-parameters)  
- [<span data-ttu-id="4c303-127">가변된 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-127">Jagged arrays</span></span>](#jagged-arrays)  
  
- [<span data-ttu-id="4c303-128">길이가 0 인 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-128">Zero-length arrays</span></span>](#zero-length-arrays)  

- [<span data-ttu-id="4c303-129">배열 분</span><span class="sxs-lookup"><span data-stu-id="4c303-129">Splitting an array</span></span>](#splitting-an-array)
  
- [<span data-ttu-id="4c303-130">배열의 대 안으로 컬렉션</span><span class="sxs-lookup"><span data-stu-id="4c303-130">Collections as an alternative to arrays</span></span>](#collections-as-an-alternative-to-arrays)  
  
##  <a name="array-elements-in-a-simple-array"></a><span data-ttu-id="4c303-131">차원 배열의 배열 요소</span><span class="sxs-lookup"><span data-stu-id="4c303-131">Array elements in a simple array</span></span>  

<span data-ttu-id="4c303-132">라는 배열을 만들어 보겠습니다 `students` 초등학교 각 학년의 학생 수를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-132">Let's create an array named `students` to store the number of students in each grade in a grammar school.</span></span> <span data-ttu-id="4c303-133">요소의 인덱스 범위는 0부터 6까지입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-133">The indexes of the elements range from 0 through 6.</span></span> <span data-ttu-id="4c303-134">이 배열을 사용 하 여 7 개의 변수를 선언 하는 보다 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-134">Using this array is simpler than declaring seven variables.</span></span>

<span data-ttu-id="4c303-135">다음 그림에 표시 된 `students` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-135">The following illustration shows the `students` array.</span></span> <span data-ttu-id="4c303-136">각 배열 요소에서</span><span class="sxs-lookup"><span data-stu-id="4c303-136">For each element of the array:</span></span>  
  
-   <span data-ttu-id="4c303-137">요소의 인덱스는 학년을 나타냅니다(인덱스 0은 유치원을 나타냄).</span><span class="sxs-lookup"><span data-stu-id="4c303-137">The index of the element represents the grade (index 0 represents kindergarten).</span></span>
  
-   <span data-ttu-id="4c303-138">요소에 포함된 값은 해당 학년의 학생 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-138">The value that’s contained in the element represents the number of students in that grade.</span></span>
  
 <span data-ttu-id="4c303-139">![학생 수를 보여 주는 배열 그림](../../../../visual-basic/programming-guide/language-features/arrays/media/arrayexampleschool.gif "ArrayExampleSchool")</span><span class="sxs-lookup"><span data-stu-id="4c303-139">![Picture of array showing numbers of students](../../../../visual-basic/programming-guide/language-features/arrays/media/arrayexampleschool.gif "ArrayExampleSchool")</span></span>  
<span data-ttu-id="4c303-140">"학생" 배열의 요소</span><span class="sxs-lookup"><span data-stu-id="4c303-140">Elements of the "students" array</span></span>  
 
<span data-ttu-id="4c303-141">다음 예제에서는 만들고 배열을 사용 하는 Visual Basic 코드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-141">The following example contains the Visual Basic code that creates and uses the array:</span></span>

 [!code-vb[simple-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/simple-array.vb)]  

<span data-ttu-id="4c303-142">이 예제에서는 세 가지를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-142">The example does three things:</span></span>

- <span data-ttu-id="4c303-143">선언 된 `students` 개의 일곱 개의 요소로 이루어진 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-143">It declares a `students` array with seven elements.</span></span> <span data-ttu-id="4c303-144">수 `6` 배열 선언은 배열의 마지막 인덱스를 나타냅니다. 즉, 하나는 배열의 요소 수보다 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-144">The number `6` in the array declaration indicates the last index in the array; it is one less than the number of elements in the array.</span></span>
- <span data-ttu-id="4c303-145">배열의 각 요소에 값을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-145">It assigns values to each element in the array.</span></span> <span data-ttu-id="4c303-146">배열 요소는 배열 이름을 사용 하 여 괄호 안에 있는 개별 요소의 인덱스를 포함 하 여 액세스 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-146">Array elements are accessed by using the array name and including the index of the individual element in parentheses.</span></span>
- <span data-ttu-id="4c303-147">배열의 각 값을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-147">It lists each value of the array.</span></span> <span data-ttu-id="4c303-148">이 예제에서는 사용을 [ `For` ](../../../language-reference/statements/for-next-statement.md) 인덱스 번호로 배열의 각 요소에 액세스 하는 문입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-148">The example uses a [`For`](../../../language-reference/statements/for-next-statement.md) statement to access each element of the array by its index number.</span></span>
  
 <span data-ttu-id="4c303-149">`students` 앞의 예제에서 배열 하나의 인덱스를 사용 하기 때문에 1 차원 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-149">The `students` array in the preceding example is a one-dimensional array because it uses one index.</span></span> <span data-ttu-id="4c303-150">둘 이상의 인덱스 또는 아래 첨자를 사용 하는 배열 이라고 *다차원*합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-150">An array that uses more than one index or subscript is called *multidimensional*.</span></span> <span data-ttu-id="4c303-151">자세한 내용은이 문서의 나머지 부분을 참조 하세요. 및 [Array Dimensions in Visual Basic](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-151">For more information, see the rest of this article and [Array Dimensions in Visual Basic](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md).</span></span>  
  
##  <a name="creating-an-array"></a><span data-ttu-id="4c303-152">배열 만들기</span><span class="sxs-lookup"><span data-stu-id="4c303-152">Creating an Array</span></span>  
 
<span data-ttu-id="4c303-153">여러 가지 방법으로 배열의 크기를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-153">You can define the size of an array in several ways:</span></span> 

- <span data-ttu-id="4c303-154">배열 선언 되 면 크기를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-154">You can specify the size when the array is declared:</span></span>
  
    [!code-vb[creating1](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#1)]  
  
 - <span data-ttu-id="4c303-155">사용할 수는 `New` 절을 만들 때 배열의 크기를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-155">You can use a `New` clause to supply the size of an array when it’s created:</span></span>  
  
    [!code-vb[creating2](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#2)]  
  
 <span data-ttu-id="4c303-156">기존 배열에 있는 경우 사용 하 여 해당 크기를 재정의할 수 있습니다 합니다 [ `Redim` ](../../../../visual-basic/language-reference/statements/redim-statement.md) 문입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-156">If you have an existing array, you can redefine its size by using the [`Redim`](../../../../visual-basic/language-reference/statements/redim-statement.md) statement.</span></span> <span data-ttu-id="4c303-157">지정할 수 있습니다는 `Redim` 문이 배열에 있는 값을 유지 하거나 빈 배열을 만들도록 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-157">You can specify that the `Redim` statement keep the values that are in the array, or you can specify that it create an empty array.</span></span> <span data-ttu-id="4c303-158">다음 예제에서는 `Redim` 문을 사용하여 기존 배열의 크기를 수정하는 여러 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-158">The following example shows different uses of the `Redim` statement to modify the size of an existing array.</span></span>  
  
 [!code-vb[redimensioning](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#3)]  
  
 <span data-ttu-id="4c303-159">자세한 내용은 참조는 [ReDim 문](../../../../visual-basic/language-reference/statements/redim-statement.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-159">For more information, see the [ReDim Statement](../../../../visual-basic/language-reference/statements/redim-statement.md).</span></span>  
  
##  <a name="storing-values-in-an-array"></a><span data-ttu-id="4c303-160">배열에 값 저장</span><span class="sxs-lookup"><span data-stu-id="4c303-160">Storing Values in an Array</span></span>
 
 <span data-ttu-id="4c303-161">`Integer` 형식의 인덱스를 사용하여 배열의 각 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-161">You can access each location in an array by using an index of type `Integer`.</span></span> <span data-ttu-id="4c303-162">괄호로 묶인 해당 인덱스를 통해 각 배열 위치를 참조하여 배열에 값을 저장하고 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-162">You can store and retrieve values in an array by referencing each array location by using its index enclosed in parentheses.</span></span> <span data-ttu-id="4c303-163">다차원 배열에 대 한 인덱스는 쉼표 (,)로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-163">Indexes for multidimensional arrays are separated by commas (,).</span></span> <span data-ttu-id="4c303-164">각 배열 차원에 대해 하나의 인덱스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-164">You need one index for each array dimension.</span></span> 

<span data-ttu-id="4c303-165">다음 예제에서는 배열에서 값을 검색 및 저장 하는 몇 가지 문을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-165">The following example shows some statements that store and retrieve values in arrays.</span></span>
  
 [!code-vb[store-and-retrieve](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/store-and-retrieve.vb)]  
  
## <a name="populating-an-array-with-array-literals"></a><span data-ttu-id="4c303-166">배열 리터럴 사용 하 여 배열 채우기</span><span class="sxs-lookup"><span data-stu-id="4c303-166">Populating an array with array literals</span></span>
 <span data-ttu-id="4c303-167">배열 리터럴을 사용 하 여 동시에 만들 배열 값의 초기 집합으로 채울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-167">By using an array literal, you can populate an array with an initial set of values at the same time that you create it.</span></span> <span data-ttu-id="4c303-168">배열 리터럴은 중괄호(`{}`)로 묶인 쉼표로 구분된 값 목록으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-168">An array literal consists of a list of comma-separated values that are enclosed in braces (`{}`).</span></span>  
  
 <span data-ttu-id="4c303-169">배열 리터럴을 사용하여 배열을 만드는 경우 배열 형식을 제공하거나 형식 유추를 사용하여 배열 형식을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-169">When you create an array by using an array literal, you can either supply the array type or use type inference to determine the array type.</span></span> <span data-ttu-id="4c303-170">다음 예제에서는 두 옵션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-170">The following example shows both options.</span></span>  
  
 [!code-vb[create-with-literals](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#4)]  
  
 <span data-ttu-id="4c303-171">형식 유추를 사용 하는 경우는 배열 형식에 의해 결정 됩니다는 *기준 형식* 리터럴 값의 목록에서입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-171">When you use type inference, the type of the array is determined by the *dominant type* in the list of literal values.</span></span> <span data-ttu-id="4c303-172">기준 형식은 배열의 다른 모든 형식과 넓힐 수 있는 형식이입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-172">The dominant type is the type to which all other types in the array can widen.</span></span> <span data-ttu-id="4c303-173">이 고유 형식을 확인할 수 없는 경우 기준 형식은 배열의 다른 모든 형식이 축소될 수 있는 고유 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-173">If this unique type can’t be determined, the dominant type is the unique type to which all other types in the array can narrow.</span></span> <span data-ttu-id="4c303-174">이러한 고유 형식을 모두 확인할 수 없는 경우 기준 형식은 `Object`입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-174">If neither of these unique types can be determined, the dominant type is `Object`.</span></span> <span data-ttu-id="4c303-175">예를 들어 배열 리터럴에 제공된 값 목록이 `Integer`, `Long`및 `Double`형식의 값을 포함하는 경우 결과 배열은 `Double`형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-175">For example, if the list of values that’s supplied to the array literal contains values of type `Integer`, `Long`, and `Double`, the resulting array is of type `Double`.</span></span> <span data-ttu-id="4c303-176">때문에 `Integer` 하 고 `Long` 로 확장 `Double`, `Double` 기준 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-176">Because `Integer` and `Long` widen only to `Double`, `Double` is the dominant type.</span></span> <span data-ttu-id="4c303-177">자세한 내용은 [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4c303-177">For more information, see [Widening and Narrowing Conversions](../../../../visual-basic/programming-guide/language-features/data-types/widening-and-narrowing-conversions.md).</span></span> 
 
> [!NOTE] 
> <span data-ttu-id="4c303-178">형식 유추에서 형식 멤버를 지역 변수로 정의 된 배열에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-178">You can use type inference only for arrays that are defined as local variables in a type member.</span></span> <span data-ttu-id="4c303-179">클래스 수준에서 배열 리터럴을 사용 하 여 정의 하는 배열 형식의 명시적 형식 정의 없으면 `Object[]`합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-179">If an explicit type definition is absent, arrays defined with array literals at the class level are of type `Object[]`.</span></span> <span data-ttu-id="4c303-180">자세한 내용은 [지역 형식 유추](../variables/local-type-inference.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-180">For more information, see [Local type inference](../variables/local-type-inference.md).</span></span> 

<span data-ttu-id="4c303-181">앞의 예제를 정의 하는 참고 `values` 형식의 배열로 `Double` 형식의 모든 배열 리터럴에 있더라도 `Integer`합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-181">Note that the previous example defines `values` as an array of type `Double` even though all the array literals are of type `Integer`.</span></span> <span data-ttu-id="4c303-182">배열 리터럴의 값을 변환할 수 있으므로이 배열을 만들 수 있습니다 `Double` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-182">You can create this array because the values in the array literal can widen to `Double` values.</span></span> 
  
 <span data-ttu-id="4c303-183">또한 만들기를 사용 하 여 다차원 배열을 채웁니다 *배열 리터럴을 중첩*합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-183">You can also create and populate a multidimensional array by using *nested array literals*.</span></span> <span data-ttu-id="4c303-184">중첩 된 배열 리터럴 결과 배열을 사용 하 여 일치 하는 차원 수가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-184">Nested array literals must have a number of dimensions that’s consistent with the resulting array.</span></span> <span data-ttu-id="4c303-185">다음 예제에서는 중첩 된 배열 리터럴을 사용 하 여 정수의 2 차원 배열을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-185">The following example creates a two-dimensional array of integers by using nested array literals.</span></span>  
  
 [!code-vb[nested-array-literals](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#5)]  
  
<span data-ttu-id="4c303-186">중첩 된 배열 리터럴을 사용 하 여 만들고 채울 배열을 중첩 된 배열 리터럴의 요소 수가 일치 하지 않는 경우 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-186">When using nested array literals to create and populate an array, an error occurs if the number of elements in the nested array literals don't match.</span></span> <span data-ttu-id="4c303-187">배열 리터럴 보다 차원 수가 다른 배열 변수를 명시적으로 선언 하는 경우에 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-187">An error also occurs if you explicitly declare the array variable to have a different number of dimensions than the array literals.</span></span> 
  
<span data-ttu-id="4c303-188">1 차원 배열에 대 한 가능한 것 처럼 중첩 된 배열 리터럴을 사용 하 여 다차원 배열을 만들 때 형식 유추를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-188">Just as you can for one-dimensional arrays, you can rely on type inference when creating a multidimensional array with nested array literals.</span></span> <span data-ttu-id="4c303-189">유추 된 유형 모든 중첩 수준에 대 한 모든 배열 리터럴에 있는 모든 값에 대 한 기준 형식이입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-189">The inferred type is the dominant type for all the values in all the array literals for all nesting level.</span></span> <span data-ttu-id="4c303-190">다음 예제에서는 형식의 2 차원 배열을 만듭니다 `Double[,]` 형식의 값에서 `Integer` 고 `Double`입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-190">The following example creates a two-dimensional array of type `Double[,]` from values that are of type `Integer` and `Double`.</span></span>  
  
 [!code-vb[nested-type-inference](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#6)]  
  
 <span data-ttu-id="4c303-191">추가 예제를 보려면 [방법: Visual Basic에서 배열 변수 초기화](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4c303-191">For additional examples, see [How to: Initialize an Array Variable in Visual Basic](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md).</span></span>  
  
##  <a name="iterating-through-an-array"></a><span data-ttu-id="4c303-192">배열 반복</span><span class="sxs-lookup"><span data-stu-id="4c303-192">Iterating through an array</span></span>  
 <span data-ttu-id="4c303-193">가장 높은 가장 낮은 인덱스 또는 높은 배열의 각 요소를 액세스 배열을 통해 반복 하는 경우 가장 낮은 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-193">When you iterate through an array, you access each element in the array from the lowest index to the highest or from the highest to the lowest.</span></span> <span data-ttu-id="4c303-194">일반적으로 사용 하 여는 [에 대 한 중... 다음 문](../../../../visual-basic/language-reference/statements/for-next-statement.md) 또는 [각각에 대 한 중... 다음 문을](../../../../visual-basic/language-reference/statements/for-each-next-statement.md) 에 배열의 요소를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-194">Typically, use either the [For...Next Statement](../../../../visual-basic/language-reference/statements/for-next-statement.md) or the [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md) to iterate through the elements of an array.</span></span> <span data-ttu-id="4c303-195">호출할 수는 배열의 상한이 모르는 경우는 <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> 메서드를 가장 높은 인덱스 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-195">When you don't know the upper bounds of the array, you can call the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method to get the highest value of the index.</span></span> <span data-ttu-id="4c303-196">가장 낮은 인덱스 값은 거의 항상 0을 호출할 수 있습니다는 <xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType> 메서드를 가장 낮은 인덱스 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-196">Although lowest index value is almost always 0, you can call the <xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType> method to get the lowest value of the index.</span></span>   
  
 <span data-ttu-id="4c303-197">다음 예제에서는 사용 하 여 1 차원 배열을 반복 합니다 [ `For...Next` ](../../../../visual-basic/language-reference/statements/for-next-statement.md) 문입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-197">The following example iterates through a one-dimensional array by using the [`For...Next`](../../../../visual-basic/language-reference/statements/for-next-statement.md) statement.</span></span> 
  
 [!code-vb[iterate-one-dimensional-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate1d.vb)]  
  
 <span data-ttu-id="4c303-198">다음 예제에서는 사용 하 여 다차원 배열을 반복을 [ `For...Next` ](../../../../visual-basic/language-reference/statements/for-next-statement.md) 문입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-198">The following example iterates through a multidimensional array by using a [`For...Next`](../../../../visual-basic/language-reference/statements/for-next-statement.md) statement.</span></span> <span data-ttu-id="4c303-199"><xref:System.Array.GetUpperBound%2A> 메서드에는 차원을 지정하는 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-199">The <xref:System.Array.GetUpperBound%2A> method has a parameter that specifies the dimension.</span></span> <span data-ttu-id="4c303-200">`GetUpperBound(0)` 첫 번째 차원의 가장 높은 인덱스를 반환 하 고 `GetUpperBound(1)` 가장 높은 두 번째 차원 인덱스를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-200">`GetUpperBound(0)` returns the highest index of the first dimension, and `GetUpperBound(1)` returns the highest index of the second dimension.</span></span>
  
 [!code-vb[iterate-two-dimensional-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate2d.vb)]  
  
 <span data-ttu-id="4c303-201">다음 예제에서는 [각각에 대 한 중... 다음 문을](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)1 차원 배열과 2 차원 배열을 반복 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-201">The following example uses a [For Each...Next Statement](../../../../visual-basic/language-reference/statements/for-each-next-statement.md)to iterate through a one-dimensional array and a two-dimensional array.</span></span>  
  
 [!code-vb[iterate-for-each-next](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate-for-each-next.vb)]  
  
## <a name="array-size"></a><span data-ttu-id="4c303-202">배열 크기</span><span class="sxs-lookup"><span data-stu-id="4c303-202">Array Size</span></span>  

 <span data-ttu-id="4c303-203">배열 크기는 모든 차원의 길이 곱입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-203">The size of an array is the product of the lengths of all its dimensions.</span></span> <span data-ttu-id="4c303-204">현재 배열에 포함된 요소의 총 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-204">It represents the total number of elements currently contained in the array.</span></span>  <span data-ttu-id="4c303-205">예를 들어, 다음 예제에서는 각 차원에 4 개의 요소가 있는 2 차원 배열을 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-205">For example, the following example declares a 2-dimensional array with four elements in each dimension.</span></span> <span data-ttu-id="4c303-206">배열의 크기는 16 예제의 출력에서 볼 수 있듯이 (또는 (3 + 1) \* (3 + 1).</span><span class="sxs-lookup"><span data-stu-id="4c303-206">As the output from the example shows, the array's size is 16 (or (3 + 1) \* (3 + 1).</span></span>

 [!code-vb[array-size](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size.vb)]  

> [!NOTE] 
> <span data-ttu-id="4c303-207">이 설명은 배열 크기는 가변된 배열에는 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-207">This discussion of array size does not apply to jagged arrays.</span></span> <span data-ttu-id="4c303-208">가변된 배열 및 가변 배열의 크기를 결정에 대 한 내용은 참조는 [가변 배열](#jagged-arrays) 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-208">For information on jagged arrays and determining the size of a jagged array, see the [Jagged arrays](#jagged-arrays) section.</span></span>
  
  <span data-ttu-id="4c303-209"><xref:System.Array.Length%2A?displayProperty=nameWithType> 속성을 사용하여 배열의 크기를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-209">You can find the size of an array by using the <xref:System.Array.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="4c303-210">사용 하 여 다차원 배열의 각 차원 길이 찾을 수는 <xref:System.Array.GetLength%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-210">You can find the length of each dimension of a multidimensional array by using the <xref:System.Array.GetLength%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="4c303-211">새 배열 개체를 할당 하 여 또는 사용 하 여 배열 변수의 크기를 조정할 수 있습니다 합니다 [ `ReDim` 문](../../../../visual-basic/language-reference/statements/redim-statement.md) 문입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-211">You can resize an array variable by assigning a new array object to it or by using the [`ReDim` Statement](../../../../visual-basic/language-reference/statements/redim-statement.md) statement.</span></span> <span data-ttu-id="4c303-212">다음 예제에서는 `ReDim` 51 요소 배열에는 100 개의 요소로 이루어진 배열을 변경 하려면.</span><span class="sxs-lookup"><span data-stu-id="4c303-212">The following example uses the `ReDim` statement to change a 100-element array to a 51-element array.</span></span>

 [!code-vb[resize-an-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size2.vb)]  
  
 <span data-ttu-id="4c303-213">배열의 크기를 처리할 때 유의해야 하는 여러 가지 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-213">There are several things to keep in mind when dealing with the size of an array.</span></span>  
  
|||  
|---|---|  
|<span data-ttu-id="4c303-214">차원 길이</span><span class="sxs-lookup"><span data-stu-id="4c303-214">Dimension Length</span></span>|<span data-ttu-id="4c303-215">각 차원의 인덱스는 0 기반, 즉,이 범위는 0부터 상한입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-215">The index of each dimension is 0-based, which means it ranges from 0 to its upper bound.</span></span> <span data-ttu-id="4c303-216">따라서 지정 된 차원의 길이 해당 차원의 선언된 된 상한 보다 큰 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-216">Therefore, the length of a given dimension is one greater than the declared upper bound of that dimension.</span></span>|  
|<span data-ttu-id="4c303-217">길이 제한</span><span class="sxs-lookup"><span data-stu-id="4c303-217">Length Limits</span></span>|<span data-ttu-id="4c303-218">배열의 각 차원 길이 최대 값 제한 합니다 `Integer` 데이터 형식, 즉 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 또는 (2 ^31)-1입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-218">The length of every dimension of an array is limited to the maximum value of the `Integer` data type, which is <xref:System.Int32.MaxValue?displayProperty=nameWithType> or (2 ^ 31) - 1.</span></span> <span data-ttu-id="4c303-219">그러나 배열의 총 크기는 시스템에서 사용 가능한 메모리에 의해서도 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-219">However, the total size of an array is also limited by the memory available on your system.</span></span> <span data-ttu-id="4c303-220">배열을 초기화 하려고 하면 사용 가능한 메모리 양을 초과 하는, 런타임에서 throw는 <xref:System.OutOfMemoryException>합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-220">If you attempt to initialize an array that exceeds the amount of available memory, the runtime throws an <xref:System.OutOfMemoryException>.</span></span>|  
|<span data-ttu-id="4c303-221">크기 및 요소 크기</span><span class="sxs-lookup"><span data-stu-id="4c303-221">Size and Element Size</span></span>|<span data-ttu-id="4c303-222">배열의 크기는 해당 요소의 데이터 형식과 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-222">An array's size is independent of the data type of its elements.</span></span> <span data-ttu-id="4c303-223">크기는 항상 메모리에 사용 하는 바이트 수가 아니라 요소의 총 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-223">The size always represents the total number of elements, not the number of bytes that they consume in memory.</span></span>|  
|<span data-ttu-id="4c303-224">메모리 소비</span><span class="sxs-lookup"><span data-stu-id="4c303-224">Memory Consumption</span></span>|<span data-ttu-id="4c303-225">배열이 메모리에 저장되는 방법에 대해서는 어떠한 가정도 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-225">It is not safe to make any assumptions regarding how an array is stored in memory.</span></span> <span data-ttu-id="4c303-226">저장소는 각 데이터 너비의 플랫폼마다 달라지므로 동일한 배열이 32비트 시스템보다 64비트 시스템에서 더 많은 메모리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-226">Storage varies on platforms of different data widths, so the same array can consume more memory on a 64-bit system than on a 32-bit system.</span></span> <span data-ttu-id="4c303-227">시스템 구성에 따라 배열을 초기화할 때 CLR(공용 언어 런타임)에서 저장소를 할당하여 요소를 최대한 가깝게 압축하거나 모두 일반적인 하드웨어 경계에 맞출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-227">Depending on system configuration when you initialize an array, the common language runtime (CLR) can assign storage either to pack elements as close together as possible, or to align them all on natural hardware boundaries.</span></span> <span data-ttu-id="4c303-228">또한 배열의 제어 정보로 인해 저장소 오버헤드가 필요하며, 차원이 추가될 때마다 이 오버헤드가 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-228">Also, an array requires a storage overhead for its control information, and this overhead increases with each added dimension.</span></span>|  

## <a name="the-array-type"></a><span data-ttu-id="4c303-229">배열 형식</span><span class="sxs-lookup"><span data-stu-id="4c303-229">The array type</span></span> 
 <span data-ttu-id="4c303-230">각 배열에는 해당 요소의 데이터 형식을 다른 데이터 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-230">Every array has a data type, which differs from the data type of its elements.</span></span> <span data-ttu-id="4c303-231">모든 배열에 대한 단일 데이터 형식은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-231">There is no single data type for all arrays.</span></span> <span data-ttu-id="4c303-232">대신, 배열의 데이터 형식은 배열의 차원 수 또는 *차수*와 배열에 있는 요소의 데이터 형식에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-232">Instead, the data type of an array is determined by the number of dimensions, or *rank*, of the array, and the data type of the elements in the array.</span></span> <span data-ttu-id="4c303-233">두 배열 변수는 동일한 차수 있는 경우에 입력 하 고 해당 요소는 동일한 데이터 형식이 동일한 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-233">Two array variables are of the same data type only when they have the same rank and their elements have the same data type.</span></span> <span data-ttu-id="4c303-234">배열의 차원 길이 배열 데이터 형식이 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-234">The lengths of the dimensions of an array do not influence the array data type.</span></span>  
  
 <span data-ttu-id="4c303-235">모든 배열은 <xref:System.Array?displayProperty=nameWithType> 클래스에서 상속되며 `Array` 형식으로 변수를 선언할 수 있지만, `Array` 형식의 배열을 만들 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-235">Every array inherits from the <xref:System.Array?displayProperty=nameWithType> class, and you can declare a variable to be of type `Array`, but you cannot create an array of type `Array`.</span></span> <span data-ttu-id="4c303-236">예를 들어, 다음 코드는 선언 되지만 `arr` 형식으로 변수를 `Array` 호출는 <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> Object 배열을, 배열의 형식을 인스턴스화하기 위한 메서드를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-236">For example, although the following code declares the `arr` variable to be of type `Array` and calls the <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> method to instantiate the array, the array's type proves to be Object[].</span></span>

 [!code-vb[array-class](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-class.vb)] 

<span data-ttu-id="4c303-237">또한 [ReDim 문](../../../../visual-basic/language-reference/statements/redim-statement.md)은 `Array` 형식으로 선언된 변수에 대해 작업할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-237">Also, the [ReDim Statement](../../../../visual-basic/language-reference/statements/redim-statement.md) cannot operate on a variable declared as type `Array`.</span></span> <span data-ttu-id="4c303-238">이러한 이유로, 및 형식 안전성에 대 한 특정 형식으로 모든 배열을 선언 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-238">For these reasons, and for type safety, it is advisable to declare every array as a specific type.</span></span>  
  
 <span data-ttu-id="4c303-239">배열이나 해당 요소의 데이터 형식을 여러 가지 방법으로 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-239">You can find out the data type of either an array or its elements in several ways.</span></span> 
  
-   <span data-ttu-id="4c303-240">호출할 수 있습니다 합니다 <xref:System.Object.GetType%2A> 메서드를 가져올 변수의 <xref:System.Type> 변수의 런타임 형식을 나타내는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-240">You can call the <xref:System.Object.GetType%2A> method on the variable to get a <xref:System.Type> object that represents the run-time type of the variable.</span></span> <span data-ttu-id="4c303-241"><xref:System.Type> 개체는 해당 속성과 메서드에 광범위한 정보를 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-241">The <xref:System.Type> object holds extensive information in its properties and methods.</span></span>  
  
-   <span data-ttu-id="4c303-242">변수를 전달할 수 있습니다는 <xref:Microsoft.VisualBasic.Information.TypeName%2A> 함수를 한 `String` 런타임 형식의 이름을 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-242">You can pass the variable to the <xref:Microsoft.VisualBasic.Information.TypeName%2A> function to get a `String` with the name of run-time type.</span></span>  
  
 <span data-ttu-id="4c303-243">다음 예제에서는 모두 호출 합니다 `GetType` 메서드 및 `TypeName` 배열의 형식을 결정 하는 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-243">The following example calls the both the `GetType` method and the `TypeName` function to determine the type of an array.</span></span> <span data-ttu-id="4c303-244">배열 형식은 `Byte(,)`합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-244">The array type is `Byte(,)`.</span></span> <span data-ttu-id="4c303-245">유의 합니다 <xref:System.Type.BaseType%2A?displayProperty=nameWithType> 속성 또한는 바이트 배열의 기본 형식임을 나타냅니다는 <xref:System.Array> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-245">Note that the <xref:System.Type.BaseType%2A?displayProperty=nameWithType> property also indicates that the base type of the byte array is the <xref:System.Array> class.</span></span>  
  
 [!code-vb[array-type](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/array-type.vb)]  
  
##  <a name="arrays-as-return-values-and-parameters"></a><span data-ttu-id="4c303-246">반환 값 및 매개 변수로 사용 되는 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-246">Arrays as return values and parameters</span></span>  
 <span data-ttu-id="4c303-247">`Function` 프로시저에서 배열을 반환하려면 배열 데이터 형식 및 차원 수를 [Function 문](../../../../visual-basic/language-reference/statements/function-statement.md)의 반환 형식으로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-247">To return an array from a `Function` procedure, specify the array data type and the number of dimensions as the return type of the [Function Statement](../../../../visual-basic/language-reference/statements/function-statement.md).</span></span> <span data-ttu-id="4c303-248">함수 내에서 동일한 데이터 형식 및 차원 수의 지역 배열 변수를 선언합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-248">Within the function, declare a local array variable with same data type and number of dimensions.</span></span> <span data-ttu-id="4c303-249">[Return 문](../../../../visual-basic/language-reference/statements/return-statement.md)에 지역 배열 변수를 괄호 없이 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-249">In the [Return Statement](../../../../visual-basic/language-reference/statements/return-statement.md), include the local array variable without parentheses.</span></span>  
  
 <span data-ttu-id="4c303-250">`Sub` 또는 `Function` 프로시저에 대한 매개 변수로 배열을 지정하려면 지정된 데이터 형식 및 차원 수의 배열로 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-250">To specify an array as a parameter to a `Sub` or `Function` procedure, define the parameter as an array with a specified data type and number of dimensions.</span></span> <span data-ttu-id="4c303-251">프로시저 호출에서 동일한 데이터 형식 및 차원 수를 사용 하 여 배열 변수를 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-251">In the call to the procedure, pass an array variable with the same data type and number of dimensions.</span></span>  
  
 <span data-ttu-id="4c303-252">다음 예제에서는 `GetNumbers` 함수에서 반환을 `Integer()`, 형식의 1 차원 배열을 `Integer`합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-252">In the following example, the `GetNumbers` function returns an `Integer()`, a one-dimensional array of type `Integer`.</span></span> <span data-ttu-id="4c303-253">`ShowNumbers` 프로시저는 `Integer()` 인수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-253">The `ShowNumbers` procedure accepts an `Integer()` argument.</span></span> 
  
 [!code-vb[return-value-and-params](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params.vb)]  
  
 <span data-ttu-id="4c303-254">다음 예제에서는 `GetNumbersMultiDim` 함수에서 반환을 `Integer(,)`, 형식의 2 차원 배열을 `Integer`합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-254">In the following example, the `GetNumbersMultiDim` function returns an `Integer(,)`, a two-dimensional array of type `Integer`.</span></span>  <span data-ttu-id="4c303-255">`ShowNumbersMultiDim` 프로시저는 `Integer(,)` 인수를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-255">The `ShowNumbersMultiDim` procedure accepts an `Integer(,)` argument.</span></span>  
  
 [!code-vb[multidimensional-return-value](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params-2d.vb)]  
  
## <a name="jagged-arrays"></a><span data-ttu-id="4c303-256">가변 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-256">Jagged Arrays</span></span>  
 
<span data-ttu-id="4c303-257">응용 프로그램의 데이터 구조가 2차원 배열이지만 사각형이 아닌 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-257">Sometimes the data structure in your application is two-dimensional but not rectangular.</span></span> <span data-ttu-id="4c303-258">예를 들어, 해당 월의 각 날짜의 최고 기온에 대 한 데이터를 저장할 배열을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-258">For example, you might use an array to store data about the high temperature of each day of the month.</span></span> <span data-ttu-id="4c303-259">배열의 첫 번째 차원에는 월을 나타내는 하지만 두 번째 차원의 일 수를 나타내는 아니며 그 달의 일 수가 균일 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-259">The first dimension of the array represents the month, but the second dimension represents the number of days, and the number of days in a month is not uniform.</span></span> <span data-ttu-id="4c303-260">*가변된 배열을*는 라고는 *배열로 이루어진 배열*, 이러한 시나리오에 대 한 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-260">A *jagged array*, which is also called an *array of arrays*, is designed for such scenarios.</span></span> <span data-ttu-id="4c303-261">가변된 배열에 요소가 들어 있는 배열도 배열이입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-261">A jagged array is an array whose elements are also arrays.</span></span> <span data-ttu-id="4c303-262">가변 배열 및 가변 배열의 각 요소에는 하나 이상의 차원이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-262">A jagged array and each element in a jagged array can have one or more dimensions.</span></span>  
  
 <span data-ttu-id="4c303-263">다음 예제는 각 요소가 일 배열인 월의 배열을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-263">The following example uses an array of months, each element of which is an array of days.</span></span> <span data-ttu-id="4c303-264">이 예제에서는 월에 다른 일 수 있으므로 가변된 배열을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-264">The example uses a jagged array because different months have different numbers of days.</span></span>  <span data-ttu-id="4c303-265">이 예제에서는 가변된 배열을 만들고, 값을 할당, 검색 및 해당 값을 표시 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-265">The example shows how to create a jagged array, assign values to it, and retrieve and display its values.</span></span>
  
 [!code-vb[jagged-arrays](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged.vb)]  

<span data-ttu-id="4c303-266">앞의 예제를 사용 하 여 요소 별로 단위로 가변된 배열에 값을 할당 한 `For...Next` 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-266">The previous example assigns values to the jagged array on an element-by-element basis by using a `For...Next` loop.</span></span> <span data-ttu-id="4c303-267">또한 가변 배열의 요소에 중첩 된 배열 리터럴을 사용 하 여 값을 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-267">You can also assign values to the elements of a jagged array by using nested array literals.</span></span> <span data-ttu-id="4c303-268">그러나 사용 하려고 중첩 배열 리터럴 (예를 들어 ```Dim valuesjagged = {{1, 2}, {2, 3, 4}}```) 컴파일러 오류가 [BC30568](../../../,,/../misc/bc30568.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-268">However, the attempt to use nested array literals (for example, ```Dim valuesjagged = {{1, 2}, {2, 3, 4}}```) generates compiler error [BC30568](../../../,,/../misc/bc30568.md).</span></span> <span data-ttu-id="4c303-269">오류를 해결 하려면 내부 배열 리터럴을 괄호로 묶어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-269">To correct the error, enclose the inner array literals in parentheses.</span></span> <span data-ttu-id="4c303-270">괄호는 배열 리터럴 식이 평가 되 고, 강제 하 고 결과 값은 다음 예제와 같이 외부 배열 리터럴과 사용 하 여 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-270">The parentheses force the array literal expression to be evaluated, and the resulting values are used with the outer array literal, as the following example shows.</span></span>  
  
 [!code-vb[jagged-array-initialization](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-assign.vb)] 

<span data-ttu-id="4c303-271">가변된 배열에 요소가 배열을 포함할 1 차원 배열이입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-271">A jagged array is a one-dimensional array whose elements contain arrays.</span></span> <span data-ttu-id="4c303-272">따라서 합니다 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성 및 `Array.GetLength(0)` 1 차원 배열에 있는 요소의 개수를 반환 하는 메서드 및 `Array.GetLength(1)` throw는 <xref:System.IndexOutOfRangeException> 가변된 배열을 다차원 없기 때문에 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-272">Therefore, the <xref:System.Array.Length%2A?displayProperty=nameWithType> property and the `Array.GetLength(0)` method return the number of elements in the one-dimensional array, and `Array.GetLength(1)` throws an <xref:System.IndexOutOfRangeException> because a jagged array is not multidimensional.</span></span> <span data-ttu-id="4c303-273">각 하위 문자열의 값을 검색 하 여 각 하위 배열에 있는 요소의 수를 결정 <xref:System.Array.Length%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-273">You determine the number of elements in each subarray by retrieving the value of each subarray's <xref:System.Array.Length%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="4c303-274">다음 예제에서는 가변된 배열의 요소 수를 결정 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-274">The following example illustrates how to determine the number of elements in a jagged array.</span></span>

[!code-vb[jagged-array-size](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-length.vb)] 

## <a name="zero-length-arrays"></a><span data-ttu-id="4c303-275">길이가 0 인 배열</span><span class="sxs-lookup"><span data-stu-id="4c303-275">Zero-length arrays</span></span>  
<span data-ttu-id="4c303-276">Visual Basic 초기화 되지 않은 배열 구별 (값이 배열을 `Nothing`) 및 *길이가 0 인 배열을* 이거나 빈 배열 (요소가 없는 배열입니다.) 초기화 되지 않은 배열이 차원이 구분 되지 않습니다는 하나 또는 모든 값을 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-276">Visual Basic differentiates between a uninitialized array (an array whose value is `Nothing`) and a *zero-length array* or empty array (an array that has no elements.) An uninitialized array is one that has not been dimensioned or had any values assigned to it.</span></span> <span data-ttu-id="4c303-277">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="4c303-277">For example:</span></span>

```vb
Dim arr() As String
```
<span data-ttu-id="4c303-278">길이가 0 인 배열은 1 차원으로 선언 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-278">A zero-length array is declared with a dimension of -1.</span></span> <span data-ttu-id="4c303-279">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="4c303-279">For example:</span></span>

```vb
Dim arrZ(-1) As String
```
<span data-ttu-id="4c303-280">다음과 같은 경우 길이가 0인 배열을 만들어야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-280">You might need to create a zero-length array under the following circumstances:</span></span>  
  
-   <span data-ttu-id="4c303-281">위험 없이 <xref:System.NullReferenceException> 예외를 코드의 멤버에 액세스 해야 합니다는 <xref:System.Array> 클래스와 같이 <xref:System.Array.Length%2A> 또는 <xref:System.Array.Rank%2A>와 같은 Visual Basic 함수를 호출 하거나 <xref:Microsoft.VisualBasic.Information.UBound%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-281">Without risking a <xref:System.NullReferenceException> exception, your code must access members of the <xref:System.Array> class, such as <xref:System.Array.Length%2A> or <xref:System.Array.Rank%2A>, or call a Visual Basic function such as <xref:Microsoft.VisualBasic.Information.UBound%2A>.</span></span>  
  
-   <span data-ttu-id="4c303-282">확인 하지 않고 코드를 단순하게 유지 하려는 `Nothing` 특수 한 경우.</span><span class="sxs-lookup"><span data-stu-id="4c303-282">You want to keep your code simple by not having to check for `Nothing` as a special case.</span></span>  
  
-   <span data-ttu-id="4c303-283">코드가 하나 이상의 프로시저에 길이가 0인 배열을 전달해야 하거나 하나 이상의 프로시저에서 길이가 0인 배열을 반환하는 API(응용 프로그래밍 인터페이스)와 상호 작용하는 경우</span><span class="sxs-lookup"><span data-stu-id="4c303-283">Your code interacts with an application programming interface (API) that either requires you to pass a zero-length array to one or more procedures or returns a zero-length array from one or more procedures.</span></span>

## <a name="splitting-an-array"></a><span data-ttu-id="4c303-284">배열 분</span><span class="sxs-lookup"><span data-stu-id="4c303-284">Splitting an array</span></span>

<span data-ttu-id="4c303-285">경우에 따라 여러 배열을 단일 배열로 분할 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-285">In some cases, you may need to split a single array into multiple arrays.</span></span> <span data-ttu-id="4c303-286">분할할 배열 되는 점을 식별 하 고 다음 배열 두 개 이상의 별도 배열로 스 피팅이 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-286">This involves identifying the point or points at which the array is to be split, and then spitting the array into two or more separate arrays.</span></span> 

> [!NOTE] 
> <span data-ttu-id="4c303-287">이 섹션에서는 단일 문자열 구분 기호에 따라 문자열 배열로 분할 하는 것을 설명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-287">This section does not discuss splitting a single string into a string array based on some delimiter.</span></span> <span data-ttu-id="4c303-288">문자열 분할에 대 한 내용은 참조는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-288">For information on splitting a string, see the <xref:System.String.Split%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="4c303-289">배열 분할에 대 한 가장 일반적인 기준은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-289">The most common criteria for splitting an array are:</span></span>

- <span data-ttu-id="4c303-290">배열의 요소 수입니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-290">The number of elements in the array.</span></span> <span data-ttu-id="4c303-291">예를 들어 다음 배열의 지정 된 수의 요소를 보다 다양 한 약 균등 한 부분으로 분할 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-291">For example, you might want to split an array of more than a specified number of elements into a number of approximately equal parts.</span></span> <span data-ttu-id="4c303-292">이 작업을 위해 값을 반환 하거나 사용할 수는 <xref:System.Array.Length%2A?displayProperty=nameWithType> 또는 <xref:System.Array.GetLength%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-292">For this purpose, you can use the value returned by either the <xref:System.Array.Length%2A?displayProperty=nameWithType> or <xref:System.Array.GetLength%2A?displayProperty=nameWithType> method.</span></span>

- <span data-ttu-id="4c303-293">배열의 위치를 나타내는 구분 기호로 사용 되는 요소의 값을 분할 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-293">The value of an element, which serves as a delimiter that indicates where the array should be split.</span></span> <span data-ttu-id="4c303-294">호출 하 여 특정 값을 검색할 수 있습니다 합니다 <xref:System.Array.FindIndex%2A?displayProperty=nameWithType> 고 <xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-294">You can search for a specific value by calling the <xref:System.Array.FindIndex%2A?displayProperty=nameWithType> and <xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType> methods.</span></span>
 
<span data-ttu-id="4c303-295">다음 호출 하 여 개별 배열 배열을 분할 해야 하는 인덱스를 결정 한 후 만들면는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-295">Once you've determined the index or indexes at which the array should be split, you can then create the individual arrays by calling the <xref:System.Array.Copy%2A?displayProperty=nameWithType> method.</span></span> 

<span data-ttu-id="4c303-296">다음 예제에서는 두 개의 배열로 대략 동일한 크기의 배열을 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-296">The following example splits an array into two arrays of approximately equal size.</span></span> <span data-ttu-id="4c303-297">(배열 요소의 총 홀수 이면 첫 번째 배열에 두 번째 보다 더 많은 요소가 하나 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="4c303-297">(If the total number of array elements is odd, the first array has one more element than the second.)</span></span> 

[!code-vb[splitting-an-array-by-length](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/split1.vb)] 

<span data-ttu-id="4c303-298">다음 예제에서는 문자열 배열 값이 배열 구분 기호로 사용 되는 "zzz" 요소의 유무에 따라 두 개의 배열을 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-298">The following example splits a string array into two arrays based on the presence of an element whose value is "zzz", which serves as the array delimiter.</span></span> <span data-ttu-id="4c303-299">새 배열 구분 기호를 포함 하는 요소를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-299">The new arrays do not include the element that contains the delimiter.</span></span>

[!code-vb[splitting-an-array-by-delimiter](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/split2.vb)] 

## <a name="joining-arrays"></a><span data-ttu-id="4c303-300">배열에 가입</span><span class="sxs-lookup"><span data-stu-id="4c303-300">Joining arrays</span></span>

<span data-ttu-id="4c303-301">또한 단일 큰 배열을 배열의 수를 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-301">You can also combine a number of arrays into a single larger array.</span></span> <span data-ttu-id="4c303-302">또한 사용이 작업을 수행 하는 <xref:System.Array.Copy%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-302">To do this, you also use the <xref:System.Array.Copy%2A?displayProperty=nameWithType> method.</span></span> 

> [!NOTE] 
> <span data-ttu-id="4c303-303">이 섹션에서는 문자열 배열을 단일 문자열로 조인 하는 것을 설명 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-303">This section does not discuss joining a string array into a single string.</span></span> <span data-ttu-id="4c303-304">조인 하는 문자열 배열에 대 한 내용은 참조는 <xref:System.String.Join%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="4c303-304">For information on joining a string array, see the <xref:System.String.Join%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="4c303-305">각 배열의 요소를 새 배열에 복사 하기 전에 먼저 accompodate 새 배열에 충분히 큰 되도록 배열 초기화 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-305">Before copying the elements of each array into the new array, you must first ensure that you have initialized the array so that it is large enough to accompodate the new array.</span></span> <span data-ttu-id="4c303-306">이 작업은 다음 두 가지 방법 중 하나로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-306">You can do this in one of two ways:</span></span>

- <span data-ttu-id="4c303-307">사용 된 [ `ReDim Preserve` ](../../../../visual-basic/language-reference/statements/redim-statement.md) 문을 동적으로 배열에 새 요소를 추가 하기 전에 확장.</span><span class="sxs-lookup"><span data-stu-id="4c303-307">Use the [`ReDim Preserve`](../../../../visual-basic/language-reference/statements/redim-statement.md) statement to dynamically expand the array before adding new elements to it.</span></span> <span data-ttu-id="4c303-308">이것이 가장 쉬운 방법 이지만 대형 배열을 복사 하는 경우 성능 저하 및 과도 한 메모리 소비에서 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-308">This is the easiest technique, but it can result in performance degradation and excessive memory consumption when you are copying large arrays.</span></span>
- <span data-ttu-id="4c303-309">새 큰 배열에 대해 필요한 요소의 총 수를 계산 다음 원본 배열의 각 요소를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-309">Calculate the total number of elements needed for the new large array, then add the elements of each source array to it.</span></span>

<span data-ttu-id="4c303-310">다음 예제에서는 10 개의 요소를 사용 하 여 4 개의 배열을 단일 배열로에 추가할 두 번째 방법을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-310">The following example uses the second approach to add four arrays with ten elements each to a single array.</span></span>  

[!code-vb[joining-an-array](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/join.vb)] 

<span data-ttu-id="4c303-311">되므로 경우 원본 배열의 모든 작은, 각 새 배열의 요소를 추가 하는 대로 배열 동적으로 확장 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-311">Since in this case the source arrays are all small, we can also dynamically expand the array as we add the elements of each new array to it.</span></span> <span data-ttu-id="4c303-312">다음 예제에서는 해당 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-312">The following example does that.</span></span>

[!code-vb[joining-an-array-dynamically](../../../../../samples/snippets/visualbasic/programming-guide/language-features/arrays/join2.vb)] 

##  <a name="collections-as-an-alternative-to-arrays"></a><span data-ttu-id="4c303-313">배열의 대 안으로 컬렉션</span><span class="sxs-lookup"><span data-stu-id="4c303-313">Collections as an alternative to arrays</span></span>  
 <span data-ttu-id="4c303-314">배열은 고정된 개수의 강력한 형식 개체를 만들고 작업하는 데 가장 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-314">Arrays are most useful for creating and working with a fixed number of strongly typed objects.</span></span> <span data-ttu-id="4c303-315">컬렉션은 개체 그룹에 대해 작업하는 보다 유연한 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-315">Collections provide a more flexible way to work with groups of objects.</span></span> <span data-ttu-id="4c303-316">배열과 달리,이 있는 배열의 크기를 명시적으로 변경 하는 필요 합니다 [ `ReDim` 문](../../../../visual-basic/language-reference/statements/redim-statement.md), 컬렉션 증가 및는 응용 프로그램 변경이 필요에 따라 동적으로 축소 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-316">Unlike arrays, which require that you explicitly change the size of an array with the [`ReDim` Statement](../../../../visual-basic/language-reference/statements/redim-statement.md), collections grow and shrink dynamically as the needs of an application change.</span></span>  
  
 <span data-ttu-id="4c303-317">사용 하는 경우 `ReDim` 배열 차원을, Visual Basic 새 배열을 만듭니다를 이전을 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-317">When you use `ReDim` to redimension an array, Visual Basic creates a new array and releases the previous one.</span></span> <span data-ttu-id="4c303-318">이 경우 실행 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-318">This takes execution time.</span></span> <span data-ttu-id="4c303-319">따라서 자주 변경 되거나 사용 중인 항목 수가 필요한 항목의 최대 수를 예측할 수 없습니다, 하는 경우 일반적으로 얻을 수 더 나은 성능을 컬렉션을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-319">Therefore, if the number of items you are working with changes frequently, or you cannot predict the maximum number of items you need, you'll usually obtain better performance by using a collection.</span></span>  
  
 <span data-ttu-id="4c303-320">일부 컬렉션의 경우 키를 사용하여 개체를 신속하게 검색할 수 있도록 컬렉션에 추가하는 모든 개체에 키를 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-320">For some collections, you can assign a key to any object that you put into the collection so that you can quickly retrieve the object by using the key.</span></span>  
  
 <span data-ttu-id="4c303-321">컬렉션에 단일 데이터 형식의 요소만 포함된 경우 <xref:System.Collections.Generic?displayProperty=nameWithType> 네임스페이스의 클래스 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-321">If your collection contains elements of only one data type, you can use one of the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="4c303-322">제네릭 컬렉션은 다른 데이터 형식을 추가할 수 없도록 형식 안전성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-322">A generic collection enforces type safety so that no other data type can be added to it.</span></span>  
  
 <span data-ttu-id="4c303-323">항목 컬렉션에 대한 자세한 내용은 [컬렉션](../../concepts/collections.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4c303-323">For more information about collections, see [Collections](../../concepts/collections.md).</span></span>
  
## <a name="related-topics"></a><span data-ttu-id="4c303-324">관련 항목</span><span class="sxs-lookup"><span data-stu-id="4c303-324">Related Topics</span></span>  
  
|<span data-ttu-id="4c303-325">용어</span><span class="sxs-lookup"><span data-stu-id="4c303-325">Term</span></span>|<span data-ttu-id="4c303-326">정의</span><span class="sxs-lookup"><span data-stu-id="4c303-326">Definition</span></span>|  
|----------|----------------|  
|[<span data-ttu-id="4c303-327">Array Dimensions in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="4c303-327">Array Dimensions in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/array-dimensions.md)|<span data-ttu-id="4c303-328">배열의 차수 및 차원을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-328">Explains rank and dimensions in arrays.</span></span>|  
|[<span data-ttu-id="4c303-329">방법: Visual Basic에서 배열 변수 초기화</span><span class="sxs-lookup"><span data-stu-id="4c303-329">How to: Initialize an Array Variable in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-initialize-an-array-variable.md)|<span data-ttu-id="4c303-330">배열에 초기 값을 채우는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-330">Describes how to populate arrays with initial values.</span></span>|  
|[<span data-ttu-id="4c303-331">방법: Visual Basic에서 배열 정렬</span><span class="sxs-lookup"><span data-stu-id="4c303-331">How to: Sort An Array in Visual Basic</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-sort-an-array.md)|<span data-ttu-id="4c303-332">배열의 요소를 사전순으로 정렬하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-332">Shows how to sort the elements of an array alphabetically.</span></span>|  
|[<span data-ttu-id="4c303-333">방법: 한 배열에 다른 배열 할당</span><span class="sxs-lookup"><span data-stu-id="4c303-333">How to: Assign One Array to Another Array</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/how-to-assign-one-array-to-another-array.md)|<span data-ttu-id="4c303-334">다른 배열 변수에 배열을 할당하는 규칙 및 단계를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-334">Describes the rules and steps for assigning an array to another array variable.</span></span>|  
|[<span data-ttu-id="4c303-335">배열 문제 해결</span><span class="sxs-lookup"><span data-stu-id="4c303-335">Troubleshooting Arrays</span></span>](../../../../visual-basic/programming-guide/language-features/arrays/troubleshooting-arrays.md)|<span data-ttu-id="4c303-336">배열에서 작업할 때 발생할 수 있는 몇 가지 일반적인 문제를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4c303-336">Discusses some common problems that arise when working with arrays.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="4c303-337">참고 항목</span><span class="sxs-lookup"><span data-stu-id="4c303-337">See Also</span></span>  
 <xref:System.Array?displayProperty=nameWithType>  
 [<span data-ttu-id="4c303-338">Dim 문</span><span class="sxs-lookup"><span data-stu-id="4c303-338">Dim Statement</span></span>](../../../../visual-basic/language-reference/statements/dim-statement.md)  
 [<span data-ttu-id="4c303-339">ReDim 문</span><span class="sxs-lookup"><span data-stu-id="4c303-339">ReDim Statement</span></span>](../../../../visual-basic/language-reference/statements/redim-statement.md)
